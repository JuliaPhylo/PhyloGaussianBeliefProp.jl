<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · PhyloGaussianBeliefProp.jl</title><meta name="title" content="Home · PhyloGaussianBeliefProp.jl"/><meta property="og:title" content="Home · PhyloGaussianBeliefProp.jl"/><meta property="twitter:title" content="Home · PhyloGaussianBeliefProp.jl"/><meta name="description" content="Documentation for PhyloGaussianBeliefProp.jl."/><meta property="og:description" content="Documentation for PhyloGaussianBeliefProp.jl."/><meta property="twitter:description" content="Documentation for PhyloGaussianBeliefProp.jl."/><meta property="og:url" content="https://JuliaPhylo.github.io/PhyloGaussianBeliefProp.jl/stable/"/><meta property="twitter:url" content="https://JuliaPhylo.github.io/PhyloGaussianBeliefProp.jl/stable/"/><link rel="canonical" href="https://JuliaPhylo.github.io/PhyloGaussianBeliefProp.jl/stable/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>PhyloGaussianBeliefProp.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Manual"><span>Manual</span></a></li><li><a class="tocitem" href="#Library"><span>Library</span></a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="man/installation/">Installation</a></li><li><a class="tocitem" href="man/getting_started/">Getting started</a></li><li><a class="tocitem" href="man/background/">Background</a></li><li><a class="tocitem" href="man/evolutionary_models/">Evolutionary models</a></li><li><a class="tocitem" href="man/clustergraphs/">Cluster graphs</a></li><li><a class="tocitem" href="man/regularization/">Regularization</a></li><li><a class="tocitem" href="man/message_schedules/">Message schedules</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PhyloGaussianBeliefProp"><a class="docs-heading-anchor" href="#PhyloGaussianBeliefProp">PhyloGaussianBeliefProp</a><a id="PhyloGaussianBeliefProp-1"></a><a class="docs-heading-anchor-permalink" href="#PhyloGaussianBeliefProp" title="Permalink"></a></h1><p><a href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl">PhyloGaussianBeliefProp</a> is a <a href="http://julialang.org">Julia</a> package for the analysis of Gaussian models on phylogenetic networks using belief propagation (aka message passing).</p><hr/><h2 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h2><ul><li><a href="man/installation/#Installation">Installation</a></li><li><a href="man/getting_started/#Getting-started">Getting started</a></li><li class="no-marker"><ul><li><a href="man/getting_started/#Exact-likelihood-for-fixed-parameters">Exact likelihood for fixed parameters</a></li><li class="no-marker"><ul><li><a href="man/getting_started/#1.-Read-in-the-network-and-the-tip-data">1. Read in the network and the tip data</a></li><li><a href="man/getting_started/#2.-Choose-an-evolutionary-model">2. Choose an evolutionary model</a></li><li><a href="man/getting_started/#3.-Build-a-cluster-graph-from-the-network">3. Build a cluster graph from the network</a></li><li><a href="man/getting_started/#4.-Initialize-cluster-graph-beliefs">4. Initialize cluster graph beliefs</a></li><li><a href="man/getting_started/#5.-Propose-a-schedule-from-the-cluster-graph">5. Propose a schedule from the cluster graph</a></li><li><a href="man/getting_started/#6.-Calibrate-beliefs-with-the-schedule">6. Calibrate beliefs with the schedule</a></li><li><a href="man/getting_started/#7.-Extract-the-log-likelihood">7. Extract the log-likelihood</a></li></ul></li><li><a href="man/getting_started/#Exact-inference">Exact inference</a></li><li><a href="man/getting_started/#Approximate-inference">Approximate inference</a></li></ul></li><li><a href="man/background/#Background">Background</a></li><li class="no-marker"><ul><li><a href="man/background/#Trait-evolution-on-a-phylogeny">Trait evolution on a phylogeny</a></li><li><a href="man/background/#Factoring-the-joint-model">Factoring the joint model</a></li><li><a href="man/background/#Parameter-inference">Parameter inference</a></li><li><a href="man/background/#BP-for-exact-inference">BP for exact inference</a></li><li><a href="man/background/#Loopy-BP-for-approximate-inference">Loopy BP for approximate inference</a></li><li><a href="man/background/#References">References</a></li></ul></li><li><a href="man/evolutionary_models/#Evolutionary-models">Evolutionary models</a></li><li class="no-marker"><ul><li><a href="man/evolutionary_models/#Specifying-a-process">Specifying a process</a></li><li><a href="man/evolutionary_models/#Edge-factors">Edge factors</a></li><li><a href="man/evolutionary_models/#Hybrid-factors">Hybrid factors</a></li></ul></li><li><a href="man/clustergraphs/#Cluster-graphs">Cluster graphs</a></li><li class="no-marker"><ul><li><a href="man/clustergraphs/#Clique-tree">Clique tree</a></li><li><a href="man/clustergraphs/#Bethe-/-Factor-graph">Bethe / Factor graph</a></li><li><a href="man/clustergraphs/#Join-graph-structuring">Join-graph structuring</a></li><li><a href="man/clustergraphs/#LTRIP">LTRIP</a></li></ul></li><li><a href="man/regularization/#Regularization">Regularization</a></li><li class="no-marker"><ul><li><a href="man/regularization/#Ill-defined-messages">Ill-defined messages</a></li><li><a href="man/regularization/#A-heuristic">A heuristic</a></li><li class="no-marker"><ul><li><a href="man/regularization/#By-cluster">By cluster</a></li><li><a href="man/regularization/#Along-node-subtrees">Along node subtrees</a></li><li><a href="man/regularization/#On-a-schedule">On a schedule</a></li></ul></li></ul></li><li><a href="man/message_schedules/#Message-schedules">Message schedules</a></li></ul><h2 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h2><ul><li><a href="#PhyloGaussianBeliefProp.AbstractClusterGraphMethod"><code>PhyloGaussianBeliefProp.AbstractClusterGraphMethod</code></a></li><li><a href="#PhyloGaussianBeliefProp.BPPosDefException"><code>PhyloGaussianBeliefProp.BPPosDefException</code></a></li><li><a href="#PhyloGaussianBeliefProp.Bethe"><code>PhyloGaussianBeliefProp.Bethe</code></a></li><li><a href="#PhyloGaussianBeliefProp.CanonicalBelief-Union{Tuple{Tlabel}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any, Type}} where Tlabel&lt;:Integer"><code>PhyloGaussianBeliefProp.CanonicalBelief</code></a></li><li><a href="#PhyloGaussianBeliefProp.CanonicalBelief"><code>PhyloGaussianBeliefProp.CanonicalBelief</code></a></li><li><a href="#PhyloGaussianBeliefProp.Cliquetree"><code>PhyloGaussianBeliefProp.Cliquetree</code></a></li><li><a href="#PhyloGaussianBeliefProp.ClusterFactor-Union{Tuple{PhyloGaussianBeliefProp.CanonicalBelief{T, Vlabel, P, V} where {Vlabel&lt;:(AbstractVector), P&lt;:AbstractMatrix{T}, V&lt;:AbstractVector{T}}}, Tuple{T}} where T"><code>PhyloGaussianBeliefProp.ClusterFactor</code></a></li><li><a href="#PhyloGaussianBeliefProp.ClusterGraphBelief-Union{Tuple{B}, Tuple{Vector{B}, Vector, Vector, BitVector, Vector}} where B&lt;:PhyloGaussianBeliefProp.AbstractBelief"><code>PhyloGaussianBeliefProp.ClusterGraphBelief</code></a></li><li><a href="#PhyloGaussianBeliefProp.ClusterGraphBelief"><code>PhyloGaussianBeliefProp.ClusterGraphBelief</code></a></li><li><a href="#PhyloGaussianBeliefProp.EvolutionaryModel"><code>PhyloGaussianBeliefProp.EvolutionaryModel</code></a></li><li><a href="#PhyloGaussianBeliefProp.GeneralizedBelief"><code>PhyloGaussianBeliefProp.GeneralizedBelief</code></a></li><li><a href="#PhyloGaussianBeliefProp.GeneralizedBelief-Union{Tuple{Tlabel}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any, Type}} where Tlabel&lt;:Integer"><code>PhyloGaussianBeliefProp.GeneralizedBelief</code></a></li><li><a href="#PhyloGaussianBeliefProp.GeneralizedBelief-Union{Tuple{PhyloGaussianBeliefProp.CanonicalBelief{T, Vlabel, P, V, M}}, Tuple{M}, Tuple{V}, Tuple{P}, Tuple{Vlabel}, Tuple{T}} where {T, Vlabel, P, V, M}"><code>PhyloGaussianBeliefProp.GeneralizedBelief</code></a></li><li><a href="#PhyloGaussianBeliefProp.HeterogeneousBrownianMotion"><code>PhyloGaussianBeliefProp.HeterogeneousBrownianMotion</code></a></li><li><a href="#PhyloGaussianBeliefProp.HeterogeneousShiftedBrownianMotion"><code>PhyloGaussianBeliefProp.HeterogeneousShiftedBrownianMotion</code></a></li><li><a href="#PhyloGaussianBeliefProp.JoinGraphStructuring"><code>PhyloGaussianBeliefProp.JoinGraphStructuring</code></a></li><li><a href="#PhyloGaussianBeliefProp.LTRIP"><code>PhyloGaussianBeliefProp.LTRIP</code></a></li><li><a href="#PhyloGaussianBeliefProp.MessageResidual-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real"><code>PhyloGaussianBeliefProp.MessageResidual</code></a></li><li><a href="#PhyloGaussianBeliefProp.MessageResidual"><code>PhyloGaussianBeliefProp.MessageResidual</code></a></li><li><a href="#PhyloGaussianBeliefProp.MvDiagBrownianMotion"><code>PhyloGaussianBeliefProp.MvDiagBrownianMotion</code></a></li><li><a href="#PhyloGaussianBeliefProp.MvFullBrownianMotion"><code>PhyloGaussianBeliefProp.MvFullBrownianMotion</code></a></li><li><a href="#PhyloGaussianBeliefProp.PaintedParameter"><code>PhyloGaussianBeliefProp.PaintedParameter</code></a></li><li><a href="#PhyloGaussianBeliefProp.UnivariateBrownianMotion"><code>PhyloGaussianBeliefProp.UnivariateBrownianMotion</code></a></li><li><a href="#PhyloGaussianBeliefProp.UnivariateOrnsteinUhlenbeck"><code>PhyloGaussianBeliefProp.UnivariateOrnsteinUhlenbeck</code></a></li><li><a href="#PhyloGaussianBeliefProp.absorbevidence!-Tuple{Any, AbstractMatrix, Any, Any, Any}"><code>PhyloGaussianBeliefProp.absorbevidence!</code></a></li><li><a href="#PhyloGaussianBeliefProp.absorbleaf!-Tuple{Any, AbstractMatrix, Any, Any, Any}"><code>PhyloGaussianBeliefProp.absorbleaf!</code></a></li><li><a href="#PhyloGaussianBeliefProp.addtreenode_belowdegeneratehybrid!-Tuple{PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.addtreenode_belowdegeneratehybrid!</code></a></li><li><a href="#PhyloGaussianBeliefProp.allocatebeliefs-Union{Tuple{T2}, Tuple{T1}, Tuple{NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Vector{PhyloNetworks.Node}, MetaGraphsNext.MetaGraph{T1, Graph} where Graph&lt;:Graphs.AbstractGraph{T1}, PhyloGaussianBeliefProp.EvolutionaryModel{T2}}} where {T1, T2}"><code>PhyloGaussianBeliefProp.allocatebeliefs</code></a></li><li><a href="#PhyloGaussianBeliefProp.assign!-Union{Tuple{T}, Tuple{Dict{T, Array{Vector{T}, 1}}, Vector{T}, T}} where T&lt;:Integer"><code>PhyloGaussianBeliefProp.assign!</code></a></li><li><a href="#PhyloGaussianBeliefProp.assignfactors!-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector{B}, PhyloGaussianBeliefProp.EvolutionaryModel, NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Vector{PhyloNetworks.Node}, Any, Any, Any}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>PhyloGaussianBeliefProp.assignfactors!</code></a></li><li><a href="#PhyloGaussianBeliefProp.average_energy"><code>PhyloGaussianBeliefProp.average_energy</code></a></li><li><a href="#PhyloGaussianBeliefProp.average_energy!-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractFactor}"><code>PhyloGaussianBeliefProp.average_energy!</code></a></li><li><a href="#PhyloGaussianBeliefProp.betheclustergraph-Tuple{PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.betheclustergraph</code></a></li><li><a href="#PhyloGaussianBeliefProp.branch_actualization-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.EvolutionaryModel{T}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}} where T"><code>PhyloGaussianBeliefProp.branch_actualization</code></a></li><li><a href="#PhyloGaussianBeliefProp.branch_displacement"><code>PhyloGaussianBeliefProp.branch_displacement</code></a></li><li><a href="#PhyloGaussianBeliefProp.branch_precision"><code>PhyloGaussianBeliefProp.branch_precision</code></a></li><li><a href="#PhyloGaussianBeliefProp.branch_variance"><code>PhyloGaussianBeliefProp.branch_variance</code></a></li><li><a href="#PhyloGaussianBeliefProp.calibrate!"><code>PhyloGaussianBeliefProp.calibrate!</code></a></li><li><a href="#PhyloGaussianBeliefProp.calibrate!"><code>PhyloGaussianBeliefProp.calibrate!</code></a></li><li><a href="#PhyloGaussianBeliefProp.calibrate_exact_cliquetree!-Union{Tuple{B}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief{B}, Any, Vector{PhyloNetworks.Node}, NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Any}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>PhyloGaussianBeliefProp.calibrate_exact_cliquetree!</code></a></li><li><a href="#PhyloGaussianBeliefProp.calibrate_optimize_cliquetree!"><code>PhyloGaussianBeliefProp.calibrate_optimize_cliquetree!</code></a></li><li><a href="#PhyloGaussianBeliefProp.calibrate_optimize_clustergraph!"><code>PhyloGaussianBeliefProp.calibrate_optimize_clustergraph!</code></a></li><li><a href="#PhyloGaussianBeliefProp.check_runningintersection-Tuple{MetaGraphsNext.MetaGraph, PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.check_runningintersection</code></a></li><li><a href="#PhyloGaussianBeliefProp.cliquetree-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T"><code>PhyloGaussianBeliefProp.cliquetree</code></a></li><li><a href="#PhyloGaussianBeliefProp.clustergraph"><code>PhyloGaussianBeliefProp.clustergraph</code></a></li><li><a href="#PhyloGaussianBeliefProp.clustergraph!-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.AbstractClusterGraphMethod}"><code>PhyloGaussianBeliefProp.clustergraph!</code></a></li><li><a href="#PhyloGaussianBeliefProp.default_rootcluster-Tuple{MetaGraphsNext.MetaGraph}"><code>PhyloGaussianBeliefProp.default_rootcluster</code></a></li><li><a href="#PhyloGaussianBeliefProp.default_rootcluster-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}"><code>PhyloGaussianBeliefProp.default_rootcluster</code></a></li><li><a href="#PhyloGaussianBeliefProp.dimension-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel}"><code>PhyloGaussianBeliefProp.dimension</code></a></li><li><a href="#PhyloGaussianBeliefProp.divide!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.GeneralizedBelief}"><code>PhyloGaussianBeliefProp.divide!</code></a></li><li><a href="#PhyloGaussianBeliefProp.entropy-Union{Tuple{Union{LinearAlgebra.Cholesky{T}, PDMats.PDMat{T, S} where S&lt;:AbstractMatrix{T}}}, Tuple{T}} where T&lt;:Real"><code>PhyloGaussianBeliefProp.entropy</code></a></li><li><a href="#PhyloGaussianBeliefProp.extend!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.GeneralizedBelief}"><code>PhyloGaussianBeliefProp.extend!</code></a></li><li><a href="#PhyloGaussianBeliefProp.factor_hybridnode-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.EvolutionaryModel{T}, AbstractVector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}}} where T"><code>PhyloGaussianBeliefProp.factor_hybridnode</code></a></li><li><a href="#PhyloGaussianBeliefProp.factor_root-Tuple{T} where T&lt;:PhyloGaussianBeliefProp.EvolutionaryModel"><code>PhyloGaussianBeliefProp.factor_root</code></a></li><li><a href="#PhyloGaussianBeliefProp.factor_treeedge-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloGaussianBeliefProp.factor_treeedge</code></a></li><li><a href="#PhyloGaussianBeliefProp.factored_energy-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}"><code>PhyloGaussianBeliefProp.factored_energy</code></a></li><li><a href="#PhyloGaussianBeliefProp.free_energy-Union{Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief{B}}, Tuple{B}, Tuple{T}} where {T&lt;:Real, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>PhyloGaussianBeliefProp.free_energy</code></a></li><li><a href="#PhyloGaussianBeliefProp.getcholesky-Tuple{AbstractMatrix}"><code>PhyloGaussianBeliefProp.getcholesky</code></a></li><li><a href="#PhyloGaussianBeliefProp.getcholesky_μ-Tuple{AbstractMatrix, Any}"><code>PhyloGaussianBeliefProp.getcholesky_μ</code></a></li><li><a href="#PhyloGaussianBeliefProp.getcholesky_μ!"><code>PhyloGaussianBeliefProp.getcholesky_μ!</code></a></li><li><a href="#PhyloGaussianBeliefProp.hasdegenerate-Tuple{PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.hasdegenerate</code></a></li><li><a href="#PhyloGaussianBeliefProp.hybridnode_displacement-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.EvolutionaryModel{T}, AbstractVector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}}} where T"><code>PhyloGaussianBeliefProp.hybridnode_displacement</code></a></li><li><a href="#PhyloGaussianBeliefProp.hybridnode_precision"><code>PhyloGaussianBeliefProp.hybridnode_precision</code></a></li><li><a href="#PhyloGaussianBeliefProp.hybridnode_variance"><code>PhyloGaussianBeliefProp.hybridnode_variance</code></a></li><li><a href="#PhyloGaussianBeliefProp.init_beliefs_allocate_atroot!-Union{Tuple{T}, Tuple{Any, Any, Any, PhyloGaussianBeliefProp.EvolutionaryModel{T}, Any, Any, Any}} where T"><code>PhyloGaussianBeliefProp.init_beliefs_allocate_atroot!</code></a></li><li><a href="#PhyloGaussianBeliefProp.init_beliefs_reset!-Union{Tuple{AbstractVector{B}}, Tuple{B}, Tuple{T}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>PhyloGaussianBeliefProp.init_beliefs_reset!</code></a></li><li><a href="#PhyloGaussianBeliefProp.init_beliefs_reset_fromfactors!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}"><code>PhyloGaussianBeliefProp.init_beliefs_reset_fromfactors!</code></a></li><li><a href="#PhyloGaussianBeliefProp.init_clustergraph-Tuple{Type{&lt;:Integer}, Symbol}"><code>PhyloGaussianBeliefProp.init_clustergraph</code></a></li><li><a href="#PhyloGaussianBeliefProp.init_factors_allocate-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector{B}, Integer}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>PhyloGaussianBeliefProp.init_factors_allocate</code></a></li><li><a href="#PhyloGaussianBeliefProp.init_factors_frombeliefs!-Union{Tuple{B}, Tuple{Any, AbstractVector{B}}, Tuple{Any, AbstractVector{B}, Bool}} where B&lt;:PhyloGaussianBeliefProp.AbstractBelief"><code>PhyloGaussianBeliefProp.init_factors_frombeliefs!</code></a></li><li><a href="#PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!"><code>PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!</code></a></li><li><a href="#PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Bool}} where T"><code>PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!</code></a></li><li><a href="#PhyloGaussianBeliefProp.init_messageresidual_allocate-Union{Tuple{T}, Tuple{Array{PhyloGaussianBeliefProp.AbstractBelief{T}, 1}, Any}} where T&lt;:Real"><code>PhyloGaussianBeliefProp.init_messageresidual_allocate</code></a></li><li><a href="#PhyloGaussianBeliefProp.inscope_onenode-Tuple{Any, PhyloGaussianBeliefProp.AbstractBelief}"><code>PhyloGaussianBeliefProp.inscope_onenode</code></a></li><li><a href="#PhyloGaussianBeliefProp.integratebelief!-Tuple{PhyloGaussianBeliefProp.CanonicalBelief}"><code>PhyloGaussianBeliefProp.integratebelief!</code></a></li><li><a href="#PhyloGaussianBeliefProp.integratebelief!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph, Any}"><code>PhyloGaussianBeliefProp.integratebelief!</code></a></li><li><a href="#PhyloGaussianBeliefProp.iscalibrated_kl!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}} where T"><code>PhyloGaussianBeliefProp.iscalibrated_kl!</code></a></li><li><a href="#PhyloGaussianBeliefProp.iscalibrated_residnorm-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}"><code>PhyloGaussianBeliefProp.iscalibrated_residnorm</code></a></li><li><a href="#PhyloGaussianBeliefProp.iscalibrated_residnorm!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any, Real}} where T"><code>PhyloGaussianBeliefProp.iscalibrated_residnorm!</code></a></li><li><a href="#PhyloGaussianBeliefProp.isdegenerate-Tuple{PhyloNetworks.Node}"><code>PhyloGaussianBeliefProp.isdegenerate</code></a></li><li><a href="#PhyloGaussianBeliefProp.isdegenerate_extendedfamily_covered-Tuple{Integer, Vector{&lt;:Integer}, Any, Any, Any}"><code>PhyloGaussianBeliefProp.isdegenerate_extendedfamily_covered</code></a></li><li><a href="#PhyloGaussianBeliefProp.isdegenerate_extendedfamily_covered-Tuple{Vector{&lt;:Integer}, Vararg{Any}}"><code>PhyloGaussianBeliefProp.isdegenerate_extendedfamily_covered</code></a></li><li><a href="#PhyloGaussianBeliefProp.isfamilypreserving-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, PhyloNetworks.HybridNetwork}} where T&lt;:Integer"><code>PhyloGaussianBeliefProp.isfamilypreserving</code></a></li><li><a href="#PhyloGaussianBeliefProp.ishybridsinglepositivechild-Tuple{PhyloNetworks.Node}"><code>PhyloGaussianBeliefProp.ishybridsinglepositivechild</code></a></li><li><a href="#PhyloGaussianBeliefProp.joingraph-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.JoinGraphStructuring}"><code>PhyloGaussianBeliefProp.joingraph</code></a></li><li><a href="#PhyloGaussianBeliefProp.ltripclustergraph-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.LTRIP}"><code>PhyloGaussianBeliefProp.ltripclustergraph</code></a></li><li><a href="#PhyloGaussianBeliefProp.marginalize-Tuple{PhyloGaussianBeliefProp.AbstractFactor, Any}"><code>PhyloGaussianBeliefProp.marginalize</code></a></li><li><a href="#PhyloGaussianBeliefProp.marginalize!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.AbstractBelief}"><code>PhyloGaussianBeliefProp.marginalize!</code></a></li><li><a href="#PhyloGaussianBeliefProp.moralize"><code>PhyloGaussianBeliefProp.moralize</code></a></li><li><a href="#PhyloGaussianBeliefProp.moralize!"><code>PhyloGaussianBeliefProp.moralize!</code></a></li><li><a href="#PhyloGaussianBeliefProp.mult!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.GeneralizedBelief}"><code>PhyloGaussianBeliefProp.mult!</code></a></li><li><a href="#PhyloGaussianBeliefProp.nodefamilies-Tuple{PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.nodefamilies</code></a></li><li><a href="#PhyloGaussianBeliefProp.nodesubtree-Tuple{MetaGraphsNext.MetaGraph, Symbol}"><code>PhyloGaussianBeliefProp.nodesubtree</code></a></li><li><a href="#PhyloGaussianBeliefProp.nodesubtree_clusterlist-Tuple{MetaGraphsNext.MetaGraph, Symbol}"><code>PhyloGaussianBeliefProp.nodesubtree_clusterlist</code></a></li><li><a href="#PhyloGaussianBeliefProp.params-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel}"><code>PhyloGaussianBeliefProp.params</code></a></li><li><a href="#PhyloGaussianBeliefProp.params_optimize-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel}"><code>PhyloGaussianBeliefProp.params_optimize</code></a></li><li><a href="#PhyloGaussianBeliefProp.params_original-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel, AbstractArray}"><code>PhyloGaussianBeliefProp.params_original</code></a></li><li><a href="#PhyloGaussianBeliefProp.parentinformation-Tuple{PhyloNetworks.Node, PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.parentinformation</code></a></li><li><a href="#PhyloGaussianBeliefProp.preprocessnet!"><code>PhyloGaussianBeliefProp.preprocessnet!</code></a></li><li><a href="#PhyloGaussianBeliefProp.propagate_1traversal_postorder!"><code>PhyloGaussianBeliefProp.propagate_1traversal_postorder!</code></a></li><li><a href="#PhyloGaussianBeliefProp.propagate_belief!-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractResidual}"><code>PhyloGaussianBeliefProp.propagate_belief!</code></a></li><li><a href="#PhyloGaussianBeliefProp.regularizebeliefs_1clustersepset!-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief, Any}"><code>PhyloGaussianBeliefProp.regularizebeliefs_1clustersepset!</code></a></li><li><a href="#PhyloGaussianBeliefProp.regularizebeliefs_bycluster!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>PhyloGaussianBeliefProp.regularizebeliefs_bycluster!</code></a></li><li><a href="#PhyloGaussianBeliefProp.regularizebeliefs_bynodesubtree!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>PhyloGaussianBeliefProp.regularizebeliefs_bynodesubtree!</code></a></li><li><a href="#PhyloGaussianBeliefProp.regularizebeliefs_onschedule!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>PhyloGaussianBeliefProp.regularizebeliefs_onschedule!</code></a></li><li><a href="#PhyloGaussianBeliefProp.residual_kldiv!-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, PhyloGaussianBeliefProp.AbstractFactor{T}}} where T&lt;:Real"><code>PhyloGaussianBeliefProp.residual_kldiv!</code></a></li><li><a href="#PhyloGaussianBeliefProp.scopeindex-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief}"><code>PhyloGaussianBeliefProp.scopeindex</code></a></li><li><a href="#PhyloGaussianBeliefProp.scopeindex-Tuple{Integer, PhyloGaussianBeliefProp.AbstractBelief}"><code>PhyloGaussianBeliefProp.scopeindex</code></a></li><li><a href="#PhyloGaussianBeliefProp.scopeindex-Tuple{Any, PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief}"><code>PhyloGaussianBeliefProp.scopeindex</code></a></li><li><a href="#PhyloGaussianBeliefProp.scopeindex-Tuple{Union{Tuple, AbstractVector}, PhyloGaussianBeliefProp.AbstractBelief}"><code>PhyloGaussianBeliefProp.scopeindex</code></a></li><li><a href="#PhyloGaussianBeliefProp.shrinkdegenerate_treeedges-Tuple{PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.shrinkdegenerate_treeedges</code></a></li><li><a href="#PhyloGaussianBeliefProp.spanningtree_clusterlist-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}"><code>PhyloGaussianBeliefProp.spanningtree_clusterlist</code></a></li><li><a href="#PhyloGaussianBeliefProp.spanningtrees_clusterlist-Union{Tuple{T}, Tuple{MetaGraphsNext.MetaGraph{T, Graph} where Graph&lt;:Graphs.AbstractGraph{T}, Vector{PhyloNetworks.Node}}} where T"><code>PhyloGaussianBeliefProp.spanningtrees_clusterlist</code></a></li><li><a href="#PhyloGaussianBeliefProp.triangulate_minfill!-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T"><code>PhyloGaussianBeliefProp.triangulate_minfill!</code></a></li><li><a href="#PhyloGaussianBeliefProp.unscope-Tuple{PhyloNetworks.Node}"><code>PhyloGaussianBeliefProp.unscope</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.AbstractClusterGraphMethod" href="#PhyloGaussianBeliefProp.AbstractClusterGraphMethod"><code>PhyloGaussianBeliefProp.AbstractClusterGraphMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractClusterGraphMethod</code></pre><p>Abstract type for cluster graph construction algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L242-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.BPPosDefException" href="#PhyloGaussianBeliefProp.BPPosDefException"><code>PhyloGaussianBeliefProp.BPPosDefException</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BPPosDefException</code></pre><p>Exception thrown when a belief message cannot be computed, that is, when the submatrix of the precision <code>J</code>, subsetted to the variables to be integrated out, is not <a href="https://en.wikipedia.org/wiki/Definiteness_of_a_matrix">positive definite</a>. It has a message <code>msg</code> field (string), and an <code>info</code> field (integer) inherited from <code>LinearAlgebra.PosDefException</code>, to indicate the location of (one of) the eigenvalue(s) which is (are) less than/equal to 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefupdates.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.Bethe" href="#PhyloGaussianBeliefProp.Bethe"><code>PhyloGaussianBeliefProp.Bethe</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bethe</code></pre><p>Subtype of <a href="#PhyloGaussianBeliefProp.AbstractClusterGraphMethod"><code>AbstractClusterGraphMethod</code></a>.</p><p><strong>Algorithm</strong></p><p>A Bethe cluster graph (also known as factor graph) has:</p><ul><li>a factor-cluster <code>{v, parents(v}}</code> for each node-family in the network, that is, for each non-root node <code>v</code> (a family is a child node and all of its parents)<ul><li>with one exception: if <code>v</code>&#39;s family is included in another family, then no factor-cluster is created for <code>v</code>.</li></ul></li><li>a variable-cluster <code>{v}</code> for each non-leaf node <code>v</code> in the network, or more specifically, for each node <code>v</code> that belongs in more than 1 factor.</li></ul><p>Each variable-cluster <code>{v}</code> is joined to the factor-clusters that contain <code>v</code>, by an edge labelled with sepset <code>{v}</code>.</p><p><strong>References</strong></p><p>D. Koller and N. Friedman. <em>Probabilistic graphical models: principles and techniques</em>. MIT Press, 2009. ISBN 9780262013192.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L254-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.CanonicalBelief" href="#PhyloGaussianBeliefProp.CanonicalBelief"><code>PhyloGaussianBeliefProp.CanonicalBelief</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CanonicalBelief{
    T&lt;:Real,
    Vlabel&lt;:AbstractVector,
    P&lt;:AbstractMatrix{T},
    V&lt;:AbstractVector{T},
    M,
} &lt;: AbstractBelief{T}</code></pre><p>A canonical belief is an exponential quadratic form with canonical parameters J, h, g (see <a href="https://juliastats.org/Distributions.jl/stable/multivariate/#Distributions.MvNormalCanon"><code>MvNormalCanon{T,P,V}</code></a> in Distributions.jl):</p><pre><code class="nohighlight hljs">C(x | J,h,g) = exp(-(1/2)xᵀJx + hᵀx + g)</code></pre><p>If J is positive-definite (i.e. J ≻ 0), then C(x | J,h,g) can be interpreted as a non-degenerate, though possibly unnormalized, distribution density for x.</p><p><strong>Fields</strong></p><ul><li><code>μ::V</code>: mean (of x); well-defined only when J ≻ 0; not always updated</li><li><code>h::V</code>: potential; interpretable as Jμ when J ≻ 0</li><li><code>J::P</code>: precision; interpretable as inv(Σ), where Σ is the variance of x, when J ≻ 0</li><li><code>g::MVector{1,T}</code>: <code>g[1]</code> is interpretable as the normalization constant for the belief</li></ul><p>when J ≻ 0</p><pre><code class="nohighlight hljs">The belief is normalized if:

        g = - (1/2) (log(2πΣ) + μ&#39;Jμ)
        = - entropy of normalized distribution + (1/2) dim(μ) - (1/2) μ&#39;Jμ.</code></pre><p>Other fields used to track which cluster or edge the belief corresponds to, and which traits of which nodes are in scope:</p><ul><li><code>nodelabel::Vlabel</code>: vector of labels (e.g. preorder indices) for nodes from the phylogeny</li></ul><p>that this belief corresponds to (i.e. whose traits distribution it describes)</p><ul><li><code>ntraits::Integer</code>: maximum number of traits per node</li><li><code>inscope::BitArray</code>: matrix of booleans (row i: trait i, column j: node j) indicating</li></ul><p>which traits are present for which nodes</p><ul><li><code>type::BeliefType</code>: cluster or sepset</li><li><code>metadata::M</code>: index (in the cluster graph) of the cluster or sepset that this belief</li></ul><p>corresponds to (e.g. ::Symbol for a cluster, ::Tuple{Symbol,Symbol} for a sepset)</p><p><strong>Methods</strong></p><ul><li><code>nodelabels(b)</code>: <code>b.nodelabel</code></li><li><code>ntraits(b)</code>: <code>b.ntraits</code></li><li><code>inscope(b)</code>: <code>b.inscope</code>, a <code>ntraits(b)</code>×<code>nodelabels(b)</code> matrix</li><li><code>nodedimensions(b)</code>: vector of integers, with jth value giving the dimension (number of traits in scope) of node j.</li><li><code>dimension(b)</code>: total dimension of the belief, that is, total number of traits in scope. Without any missing data, that would be <code>ntraits(b)</code>*<code>nodelabels(b)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L22-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.CanonicalBelief-Union{Tuple{Tlabel}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any, Type}} where Tlabel&lt;:Integer" href="#PhyloGaussianBeliefProp.CanonicalBelief-Union{Tuple{Tlabel}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any, Type}} where Tlabel&lt;:Integer"><code>PhyloGaussianBeliefProp.CanonicalBelief</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CanonicalBelief(nodelabels, numtraits, inscope, belieftype, metadata, T=Float64)</code></pre><p>Constructor to allocate memory for one cluster, and initialize objects with 0s to initialize the belief with the constant function exp(0)=1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.Cliquetree" href="#PhyloGaussianBeliefProp.Cliquetree"><code>PhyloGaussianBeliefProp.Cliquetree</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Cliquetree</code></pre><p>Subtype of <a href="#PhyloGaussianBeliefProp.AbstractClusterGraphMethod"><code>AbstractClusterGraphMethod</code></a>.</p><p><strong>Algorithm</strong></p><ol><li><a href="#PhyloGaussianBeliefProp.moralize"><code>moralize</code></a> the network (connect partners that share a child).</li><li>triangulate the resulting undirected graph using greedy min-fill, see <a href="#PhyloGaussianBeliefProp.triangulate_minfill!-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T"><code>triangulate_minfill!(graph)</code></a>.</li><li>extract the maximal cliques of the resulting chordal graph.</li><li>calculate the edge weight between each pair of maximal cliques as the size of their intersection</li><li>find a maximum-weight spanning tree</li><li>label the retained edges (in the spanning tree) by the intersection of the two cliques they connect.</li></ol><p><strong>References</strong></p><p>D. Koller and N. Friedman. <em>Probabilistic graphical models: principles and techniques</em>. MIT Press, 2009. ISBN 9780262013192.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L412-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.ClusterFactor-Union{Tuple{PhyloGaussianBeliefProp.CanonicalBelief{T, Vlabel, P, V} where {Vlabel&lt;:(AbstractVector), P&lt;:AbstractMatrix{T}, V&lt;:AbstractVector{T}}}, Tuple{T}} where T" href="#PhyloGaussianBeliefProp.ClusterFactor-Union{Tuple{PhyloGaussianBeliefProp.CanonicalBelief{T, Vlabel, P, V} where {Vlabel&lt;:(AbstractVector), P&lt;:AbstractMatrix{T}, V&lt;:AbstractVector{T}}}, Tuple{T}} where T"><code>PhyloGaussianBeliefProp.ClusterFactor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ClusterFactor(belief::AbstractBelief{T}) where T</code></pre><p>Constructor to allocate memory for one cluster factor, with canonical parameters and metadata initialized to be a copy of those in <code>belief</code>. <code>ClusterFactor</code>s metadata are supposed to be symbols, so this constructor should fail if its input is a sepset belief, whose <code>metadata</code> is a Tuple of Symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L596-L603">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.ClusterGraphBelief" href="#PhyloGaussianBeliefProp.ClusterGraphBelief"><code>PhyloGaussianBeliefProp.ClusterGraphBelief</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ClusterGraphBelief{B&lt;:AbstractBelief, F&lt;:ClusterFactor, M&lt;:MessageResidual}</code></pre><p>Structure to hold a vector of beliefs, with cluster beliefs coming first and sepset beliefs coming last. Fields:</p><ul><li><code>belief</code>: vector of beliefs</li><li><code>factor</code>: vector of initial cluster beliefs after factor assignment</li><li><code>nclusters</code>: number of clusters</li><li><code>cdict</code>: dictionary to get the index of a cluster belief from its node labels</li><li><code>sdict</code>: dictionary to get the index of a sepset belief from the labels of  its two incident clusters</li><li><code>messageresidual</code>: dictionary to log information about sepset messages, which can be used to track calibration or help adaptive scheduling with residual BP. See <a href="#PhyloGaussianBeliefProp.MessageResidual"><code>MessageResidual</code></a>. The keys of <code>messageresidual</code> are tuples of cluster labels, similar to a sepset&#39;s metadata. Each edge in the cluster graph has 2 messages corresponding to the 2 directions in which a message can be passed, with keys: <code>(label1, label2)</code> and <code>(label2, label1)</code>. The cluster receiving the message is the first label in the tuple, and the sending cluster is the second.</li></ul><p>Assumptions:</p><ul><li>For a cluster belief, the cluster&#39;s nodes are stored in the belief&#39;s <code>metadata</code>.</li><li>For a sepset belief, its incident clusters&#39; nodes are in the belief&#39;s metadata.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraphbeliefs.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.ClusterGraphBelief-Union{Tuple{B}, Tuple{Vector{B}, Vector, Vector, BitVector, Vector}} where B&lt;:PhyloGaussianBeliefProp.AbstractBelief" href="#PhyloGaussianBeliefProp.ClusterGraphBelief-Union{Tuple{B}, Tuple{Vector{B}, Vector, Vector, BitVector, Vector}} where B&lt;:PhyloGaussianBeliefProp.AbstractBelief"><code>PhyloGaussianBeliefProp.ClusterGraphBelief</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ClusterGraphBelief(belief_vector::Vector{B})</code></pre><p>Constructor of a <code>ClusterGraphBelief</code> with belief <code>belief_vector</code> and all other fields constructed accordingly. New memory is allocated for these other fields, e.g. for factors (with data copied from cluster beliefs) and message residuals (with data initialized to 0 but of size matching that from sepset beliefs)</p><p>To construct the input vector of beliefs, see <a href="#PhyloGaussianBeliefProp.allocatebeliefs-Union{Tuple{T2}, Tuple{T1}, Tuple{NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Vector{PhyloNetworks.Node}, MetaGraphsNext.MetaGraph{T1, Graph} where Graph&lt;:Graphs.AbstractGraph{T1}, PhyloGaussianBeliefProp.EvolutionaryModel{T2}}} where {T1, T2}"><code>allocatebeliefs</code></a> and <a href="#PhyloGaussianBeliefProp.assignfactors!-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector{B}, PhyloGaussianBeliefProp.EvolutionaryModel, NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Vector{PhyloNetworks.Node}, Any, Any, Any}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>assignfactors!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraphbeliefs.jl#L78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.EvolutionaryModel" href="#PhyloGaussianBeliefProp.EvolutionaryModel"><code>PhyloGaussianBeliefProp.EvolutionaryModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EvolutionaryModel{T}</code></pre><p>Evolutionary model type, with <code>T</code> the element type in all parameter vector and matrices. Implemented models include the <a href="#PhyloGaussianBeliefProp.UnivariateBrownianMotion"><code>UnivariateBrownianMotion</code></a>.</p><p>An object of this type must contain at least the following elements:</p><ul><li>μ: the mean of the trait at the root.</li><li>v: the variance of the trait at the root. Can be zero (fixed root) or infinite.</li></ul><p>New evolutionary models must implement the following interfaces:</p><pre><code class="language-julia hljs">params(obj::EvolutionaryModel)
params_optimize(obj::EvolutionaryModel)
params_original(obj::EvolutionaryModel, transformedparams::AbstractArray)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.GeneralizedBelief" href="#PhyloGaussianBeliefProp.GeneralizedBelief"><code>PhyloGaussianBeliefProp.GeneralizedBelief</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneralizedBelief{
    T&lt;:Real,
    Vlabel&lt;:AbstractVector,
    P&lt;:AbstractMatrix{T},
    V&lt;:AbstractVector{T},
    M,
} &lt;: AbstractBelief{T}</code></pre><p>A generalized belief is the product of an exponential quadratic form and a Dirac measure (generalizing the <a href="#PhyloGaussianBeliefProp.CanonicalBelief"><code>CanonicalBelief</code></a>) with generalized parameters Q, R, Λ, h, c, g:</p><pre><code class="nohighlight hljs">𝒟(x | Q,R,Λ,h,c,g) = exp(-(1/2)xᵀ(QΛQᵀ)x + (Qh)ᵀx + g) • δ(Rᵀx - c)</code></pre><p>For m-dimensional x (i.e. x ∈ ℝᵐ), [Q R] is assumed to be m × m orthonormal (i.e. [Q R]ᵀ[Q R] = Iₘ) such that Q and R are orthogonal (i.e. QᵀR = 0).</p><p>Generally, Q is m × (m-k) and R is m × k, where 0 ≤ k ≤ m. We refer to R as the constraint matrix (R represents linear dependencies among the variables of x) and to k as the constraint rank. Λ is (m-k) × (m-k) diagonal, h and c are respectively m × 1 and k × 1, and g is scalar.</p><p>When k=0, a generalized belief is equivalent to a canonical belief with canonical parameters J₁=QΛQᵀ, h₁=Qh, g₁=g.</p><p><strong>Fields</strong></p><ul><li><code>μ::V</code>: m × 1, where <code>μ[1:(m-k)]</code> stores (QΛQᵀ)⁻¹Qh = QΛ⁻¹h, the mean of x; well-defined</li></ul><p>only when QΛQᵀ is positive-definite (i.e. Q is square and Λ has no zero-entries on its diagonal); not always updated</p><ul><li><code>h::V</code>: m × 1 vector, where <code>h[1:(m-k)]</code> stores generalized parameter h. Note that is</li></ul><p><strong>not</strong> the potential for a canonical belief.</p><ul><li><code>Q::P</code>: m × m matrix, where <code>Q[:,1:(m-k)]</code> stores generalized parameter Q</li><li><code>Λ::V</code>: m × 1 vector, where <code>Diagonal(Λ[1:(m-k)])</code> gives generalized parameter Λ</li><li><code>g::MVector{1,T}</code>: <code>g[1]</code> stores the generalized parameter g</li><li><code>k::MVector{1,Int}</code>: <code>k[1]</code> stores the constraint rank k</li><li><code>R::P</code>: m × m matrix, where <code>R[:,1:k]</code> stores the generalized parameter R (i.e. the</li></ul><p>constraint matrix)</p><ul><li><code>c::V</code>: m × 1 matrix, where <code>c[1:k]</code> stores the the generalized parameter c</li></ul><p><code>hmsg</code>, <code>Qmsg</code>, <code>Λmsg</code>, <code>gmsg</code>, <code>kmsg</code>, <code>Rmsg</code>, <code>cmsg</code> are matrices/vectors of the same dimensions as <code>h</code>, <code>Q</code>, <code>Λ</code>, <code>g</code>, <code>k</code>, <code>R</code>, <code>c</code> and are meant to store (1) the outgoing message for a sending cluster, (2) the incoming message for a receiving cluster, or (3) the message quotient (from dividing an outgoing message by a sepset belief) for a mediating sepset. We refer to these as the <em>message fields</em> of the generalized belief.</p><p>Other fields (defined identically as for <a href="#PhyloGaussianBeliefProp.CanonicalBelief"><code>CanonicalBelief</code></a>) used to track which cluster or edge the belief corresponds to, and which traits of which nodes are in scope:</p><ul><li><code>nodelabel::Vlabel</code></li><li><code>ntraits::Integer</code></li><li><code>inscope::BitArray</code></li><li><code>type::BeliefType</code></li><li><code>metadata::M</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L134-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.GeneralizedBelief-Union{Tuple{PhyloGaussianBeliefProp.CanonicalBelief{T, Vlabel, P, V, M}}, Tuple{M}, Tuple{V}, Tuple{P}, Tuple{Vlabel}, Tuple{T}} where {T, Vlabel, P, V, M}" href="#PhyloGaussianBeliefProp.GeneralizedBelief-Union{Tuple{PhyloGaussianBeliefProp.CanonicalBelief{T, Vlabel, P, V, M}}, Tuple{M}, Tuple{V}, Tuple{P}, Tuple{Vlabel}, Tuple{T}} where {T, Vlabel, P, V, M}"><code>PhyloGaussianBeliefProp.GeneralizedBelief</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneralizedBelief(b::CanonicalBelief)</code></pre><p>Constructor from a canonical belief <code>b</code>.</p><p>Precision <code>b.J</code> is eigendecomposed into <code>Q Λ transpose(Q)</code>, where <code>Q</code> and <code>Λ</code> are square with the same dimensions as <code>b.J</code>, and <code>Λ</code> is positive semidefinite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L263-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.GeneralizedBelief-Union{Tuple{Tlabel}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any, Type}} where Tlabel&lt;:Integer" href="#PhyloGaussianBeliefProp.GeneralizedBelief-Union{Tuple{Tlabel}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any, Type}} where Tlabel&lt;:Integer"><code>PhyloGaussianBeliefProp.GeneralizedBelief</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneralizedBelief(nodelabels, numtraits, inscope, belieftype, metadata, T=Float64)</code></pre><p>Constructor to allocate memory for one cluster, and initialize objects with zeros to initialize the belief with the constant function exp(0)=1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L228-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.HeterogeneousBrownianMotion" href="#PhyloGaussianBeliefProp.HeterogeneousBrownianMotion"><code>PhyloGaussianBeliefProp.HeterogeneousBrownianMotion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HeterogeneousBrownianMotion{T,U,V,W} &lt;: HeterogeneousBM{T}</code></pre><p>Type for a heterogeneous Brownian motion model, univariate or multivariate. Along each edge, evolution follows a Brownian motion. Each edge can have its own variance rate. This model has no shifts, and no extra hybrid variance. By default, the root is fixed with prior variance 0.</p><p><code>T</code> is the scalar type, <code>U</code> is the type for the root mean (vector of length d, where <code>d</code> is the trait dimension, even if univariate), <code>V</code> is a matrix type for the root variance, and <code>W</code> the matrix type of each variance rate, one per color. For a univariate BM, we may have <code>W=T</code> and <code>V=Vector{T}</code>. For a multivariate BM, we may have <code>W=V&lt;:Matrix{T}</code>. This is such that each field is mutable, so we can update model parameters in place within the model object, itself immutable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/heterogeneousmodels.jl#L53-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.HeterogeneousShiftedBrownianMotion" href="#PhyloGaussianBeliefProp.HeterogeneousShiftedBrownianMotion"><code>PhyloGaussianBeliefProp.HeterogeneousShiftedBrownianMotion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HeterogeneousShiftedBrownianMotion{T,U,V,W} &lt;: HeterogeneousBM{T}</code></pre><p>Type for a heterogeneous Brownian motion model like <a href="#PhyloGaussianBeliefProp.HeterogeneousBrownianMotion"><code>HeterogeneousBrownianMotion</code></a> but with a possible shift in the mean along each edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/heterogeneousmodels.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.JoinGraphStructuring" href="#PhyloGaussianBeliefProp.JoinGraphStructuring"><code>PhyloGaussianBeliefProp.JoinGraphStructuring</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JoinGraphStructuring</code></pre><p>Subtype of <a href="#PhyloGaussianBeliefProp.AbstractClusterGraphMethod"><code>AbstractClusterGraphMethod</code></a>.</p><p><strong>Fieldnames</strong></p><ul><li><code>maxclustersize</code>: upper limit for cluster size. This value must be at least the size of the largest node family in the input phylogenetic network, normally 3 if the network is bicombining (each hybrid node has 2 parents, never more). See <a href="#PhyloGaussianBeliefProp.nodefamilies-Tuple{PhyloNetworks.HybridNetwork}"><code>nodefamilies(net)</code></a>.</li></ul><p><strong>Constructors</strong></p><ul><li><code>JoinGraphStructuring(maxclustersize, net)</code>:  checks that the input <code>maxclustersize</code> is valid for <code>net</code></li></ul><p><strong>Algorithm, by Mateescu et al. (2010)</strong></p><p>Requires:</p><ul><li>a user-specified maximum cluster size</li><li>an elimination order for the nodes in the HybridNetwork, hopefully yielding a small induced-width, e.g. from a heuristic such as greedy min-fill (see <a href="#PhyloGaussianBeliefProp.triangulate_minfill!-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T"><code>triangulate_minfill!(graph)</code></a>).</li></ul><ol><li>Each node in <code>net</code> labels a &quot;bucket&quot;, and these buckets are ordered according to the elimination order, e.g. the highest-priority bucket is labelled by the first node in the elimination order.</li><li>Node families are assigned to buckets based on the highest-priority node they contain. For example, if {1,4,9} forms a node family and if node 4 is higher in the elimination order than nodes 1 or 9, then {1,4,9} gets assigned to bucket 4.</li><li>Node families are clusters (of nodes), and we refer to the clusters within a bucket as &quot;minibuckets&quot;. Minibuckets within a bucket can be merged as long as the size of their union does not exceed the maximum cluster size allowed. Sometimes, this can be done in multiple ways.</li><li>Starting with the highest-priority bucket, we create new minibuckets by &quot;marginalizing out&quot; the bucket label from each existing minibucket (these are left unchanged in the process).</li><li>Each new minibucket is joined to its &quot;originator&quot; minibucket by an edge that is labeled by their intersection (i.e. the variables in the new minibucket). Each new minibucket is then reassigned to a new (and necessarily lower-priority) bucket based on its highest priority node. Merging can take place during reassignment as long as the the maximum cluster size is respected. The union of 2 minibuckets retains the edges of each of minibucket.</li><li>Steps 4 &amp; 5 are carried out for each bucket in order of priority.</li><li>The resulting minibuckets in each bucket are then joined in a chain (there is some degree of freedom for how this can be done), where each edge is labelled by the bucket label.</li></ol><p><strong>References</strong></p><p>R. Mateescu, K. Kask, V.Gogate, and R. Dechter. Join-graph propagation algorithms. <em>Journal of Artificial Intelligence Research</em>, 37:279-328, 2010 doi: <a href="https://doi.org/10.1613/jair.2842">10.1613/jair.2842</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L346-L401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.LTRIP" href="#PhyloGaussianBeliefProp.LTRIP"><code>PhyloGaussianBeliefProp.LTRIP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LTRIP{T&lt;:Integer}</code></pre><p>Subtype of <a href="#PhyloGaussianBeliefProp.AbstractClusterGraphMethod"><code>AbstractClusterGraphMethod</code></a>. A HybridNetwork and a valid LTRIP are passed to <a href="#PhyloGaussianBeliefProp.clustergraph!-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.AbstractClusterGraphMethod}"><code>clustergraph!</code></a> to construct a cluster graph from the user-provided clusters based on the <em>Layered Trees Running Intersection Property</em> algorithm of Streicher &amp; du Preez (2017).</p><p><strong>Fieldnames</strong></p><ul><li>clusters: vector of clusters, required to be family-preserving with respect to some HybridNetwork – see <a href="#PhyloGaussianBeliefProp.isfamilypreserving-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, PhyloNetworks.HybridNetwork}} where T&lt;:Integer"><code>isfamilypreserving</code></a>. Within each cluster, nodes (identified by their preorder index in the network) are required to be sorted in decreasing order (for postorder)</li></ul><p><strong>Constructors</strong></p><ul><li><code>LTRIP(net)</code>: uses <a href="#PhyloGaussianBeliefProp.nodefamilies-Tuple{PhyloNetworks.HybridNetwork}"><code>nodefamilies(net)</code></a> as input clusters, which are guaranteed to be family-preserving</li><li><code>LTRIP(clusters, net)</code>: checks if that clusters provided are family-preserving,  then sorts each cluster in decreasing order (modifying them in place!)  before creating the LTRIP object.</li></ul><p>They assume, <em>with no check</em>, that <code>net</code> already has a preordering.</p><p><strong>Algorithm</strong></p><ol><li>An initial graph G is considered, in which each input cluster is a node. An edge (C1,C2) is added if clusters C1 and C2 share at least 1 node (in <code>net</code>). The weight of edge (C1,C2) is defined as the size of the intersection C1 ∩ C2.</li><li>For each node <code>n</code> in <code>net</code>, the subgraph of G induced by the clusters containing <code>n</code>, G_n, has its weights adjusted as follows:<ul><li>the edges of maximum weight (within G_n) are identified, then</li><li>the weight of each edge is increased by the number of max-weight edges that either of its endpoints adjacent to.</li></ul>Then, LTRIP finds a maximum-weight spanning tree of G_n. The edges of this tree are all labelled with <code>{n}</code> (or its label or preorder index).</li><li>The spanning trees for each node are layered on one another to form a cluster graph. In other words, an edge (C1,C2) is added if it is present is any spanning tree. If so, its sepset is the union of its labels across the different spanning trees.</li></ol><p><strong>References</strong></p><p>S. Streicher and J. du Preez. Graph Coloring: Comparing Cluster Graphs to Factor Graphs. In <em>Proceedings of the ACM Multimedia 2017 Workshop on South African Academic Participation</em>, pages 35-42, 2017. doi: <a href="https://doi.org/10.1145/3132711.3132717">10.1145/3132711.3132717</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L280-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.MessageResidual" href="#PhyloGaussianBeliefProp.MessageResidual"><code>PhyloGaussianBeliefProp.MessageResidual</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MessageResidual{T&lt;:Real, P&lt;:AbstractMatrix{T}, V&lt;:AbstractVector{T}} &lt;: AbstractResidual{T}</code></pre><p>Structure to store the most recent computation history of a message, in the form of the ratio: sent_message / current_sepset_belief, when a message is sent from one cluster to another along a given sepset. At calibration, this ratio is 1. For Gaussian beliefs, this ratio is an exponential quadratic form, stored using its canonical parametrization, excluding the constant.</p><p>Fields:</p><ul><li><code>Δh</code>: canonical parameter vector of the message residual</li><li><code>ΔJ</code>: canonical parameter matrix of the message residual</li><li><code>kldiv</code>: kl divergence between the message that was last sent and the  sepset belief before the last update</li><li><code>iscalibrated_resid</code>: true if the last message and prior sepset belief were approximately equal, false otherwise. see <a href="#PhyloGaussianBeliefProp.iscalibrated_residnorm!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any, Real}} where T"><code>iscalibrated_residnorm!</code></a></li><li><code>iscalibrated_kl</code>: same, but in terms of the KL divergence, see <a href="#PhyloGaussianBeliefProp.iscalibrated_kl!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}} where T"><code>iscalibrated_kl!</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L874-L894">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.MessageResidual-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real" href="#PhyloGaussianBeliefProp.MessageResidual-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Real"><code>PhyloGaussianBeliefProp.MessageResidual</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MessageResidual(J::AbstractMatrix{T}, h::AbstractVector{T})</code></pre><p>Constructor to allocate memory for a <code>MessageResidual</code> with canonical parameters <code>(ΔJ, Δh)</code> of the same dimension and type as <code>J</code> and <code>h</code>, initialized to zeros. <code>kldiv</code> is initalized to <code>[-1.0]</code> and the flags <code>iscalibrated_{resid,kl}</code> are initialized to <code>false</code> if the message is of positive dimension. If the message is empty (ΔJ and Δh of dimension 0) then the message is initialized as being calibrated: <code>kldiv</code> is set to 0 and <code>iscalibrated</code> flags set to true.</p><p><code>(ΔJ, Δh)</code> of zero suggest calibration, but the flags <code>iscalibrated_{resid,kl}</code> being false indicate otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L903-L915">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.MvDiagBrownianMotion" href="#PhyloGaussianBeliefProp.MvDiagBrownianMotion"><code>PhyloGaussianBeliefProp.MvDiagBrownianMotion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MvDiagBrownianMotion{T,V} &lt;: HomogeneousBrownianMotion{T}</code></pre><p>The multivariate Brownian motion with diagonal variance rate matrix, that is, traits with independent evolution. It is homogeneous across the phylogeny. <code>R</code> is the variance rate (stored as a vector of type <code>V</code>), <code>μ</code> is the prior mean at the root and <code>v</code> the prior variance at the root, 0 by default (and both also of type <code>V</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/homogeneousbrownianmotion.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.MvFullBrownianMotion" href="#PhyloGaussianBeliefProp.MvFullBrownianMotion"><code>PhyloGaussianBeliefProp.MvFullBrownianMotion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MvFullBrownianMotion{T,P1,V,P2} &lt;: HomogeneousBrownianMotion{T}</code></pre><p>The full multivariate Brownian motion. It is homogeneous across the phylogeny. <code>R</code> is the variance rate (of matrix type <code>P1</code>), <code>μ</code> is the prior mean at the root (of vector type <code>V</code>) and <code>v</code> the prior variance at the root, 0 by default (of matrix type <code>P2</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/homogeneousbrownianmotion.jl#L93-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.PaintedParameter" href="#PhyloGaussianBeliefProp.PaintedParameter"><code>PhyloGaussianBeliefProp.PaintedParameter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PaintedParameter{T}</code></pre><p>Type with 2 fields:</p><ul><li><code>parameter</code>: vector whose elements are of type <code>T</code></li><li><code>color</code>: <code>DefaultDict</code> dictionary mapping integers to integers, with a default value of 1.</li></ul><p><code>ncolors(pp)</code> returns the number of parameters, that is, the length of <code>pp.parameter</code> This type is meant to store several values for a given evolutionary parameter (say, Brownian motion variance rate), each one being used on some edges or nodes of a phylogenetic network. The default parameter value is the first one.</p><p>For an edge number <code>i</code>, color <code>j=pp.color[i]</code> indexes its parameter value, that is, evolution along edge number <code>i</code> should use <code>pp.parameter[j]</code>. This parameter value is obtained with <code>getparameter(pp, j)</code> for the parameter value of color <code>j</code>, or <code>getparameter(pp, edge)</code> for the parameter value of <code>edge</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/heterogeneousmodels.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.UnivariateBrownianMotion" href="#PhyloGaussianBeliefProp.UnivariateBrownianMotion"><code>PhyloGaussianBeliefProp.UnivariateBrownianMotion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnivariateBrownianMotion{T} &lt;: HomogeneousBrownianMotion{T}</code></pre><p>The univariate Brownian motion, homogeneous across the phylogeny, that is, with the same variance rate <code>σ2</code> across all edges. <code>μ</code> is the prior mean at the root. <code>v</code> the prior variance at the root, 0 by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/homogeneousbrownianmotion.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.UnivariateOrnsteinUhlenbeck" href="#PhyloGaussianBeliefProp.UnivariateOrnsteinUhlenbeck"><code>PhyloGaussianBeliefProp.UnivariateOrnsteinUhlenbeck</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnivariateOrnsteinUhlenbeck{T} &lt;: HomogeneousOrnsteinUhlenbeck{T}</code></pre><p>The univariate Ornstein-Uhlenbeck model. It is homogeneous, that is, has the same parameters across all edges in the phylogeny. <code>σ2</code> is the variance rate, <code>α</code> the selection strength, <code>θ</code> the optimal value, <code>μ</code> the prior mean at the root, and <code>v</code> the prior variance at the root, 0 by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/homogeneousornsteinuhlenbeck.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.absorbevidence!-Tuple{Any, AbstractMatrix, Any, Any, Any}" href="#PhyloGaussianBeliefProp.absorbevidence!-Tuple{Any, AbstractMatrix, Any, Any, Any}"><code>PhyloGaussianBeliefProp.absorbevidence!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">absorbevidence!(h,J,g, dataindex, datavalues)</code></pre><p>Absorb evidence, at indices <code>dataindex</code> and using <code>datavalues</code>. Warnings:</p><ul><li>a subset of <code>h</code> is modified in place</li><li>traits are assumed to come in the same order in <code>dataindex</code> as in <code>datavalues</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefupdates.jl#L202-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.absorbleaf!-Tuple{Any, AbstractMatrix, Any, Any, Any}" href="#PhyloGaussianBeliefProp.absorbleaf!-Tuple{Any, AbstractMatrix, Any, Any, Any}"><code>PhyloGaussianBeliefProp.absorbleaf!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">absorbleaf!(h,J,g, rowindex, columntable)</code></pre><p>Absorb evidence from a leaf, given in <code>col[rowindex]</code> of each column in the table, then marginalizes out any variable for a missing trait at that leaf. See <a href="#PhyloGaussianBeliefProp.absorbevidence!-Tuple{Any, AbstractMatrix, Any, Any, Any}"><code>absorbevidence!</code></a> and <a href="#PhyloGaussianBeliefProp.marginalize-Tuple{PhyloGaussianBeliefProp.AbstractFactor, Any}"><code>marginalize</code></a>. Warning: The leaf traits are assumed to correspond to the first variables in <code>h</code> (and <code>J</code>), as is output by <a href="#PhyloGaussianBeliefProp.factor_treeedge-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>factor_treeedge</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefupdates.jl#L256-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.addtreenode_belowdegeneratehybrid!-Tuple{PhyloNetworks.HybridNetwork}" href="#PhyloGaussianBeliefProp.addtreenode_belowdegeneratehybrid!-Tuple{PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.addtreenode_belowdegeneratehybrid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addtreenode_belowdegeneratehybrid!(net::HybridNetwork)</code></pre><p>If a degenerate hybrid node h1 has 1 child edge of length t&gt;0 to a hybrid child h2: break the edge by adding a tree node at distance t from h1 and 0 from h2. That way, h1 may be removed from scope. This is done iteratively, as h2 may become degenerate after this operation. See <a href="#PhyloGaussianBeliefProp.shrinkdegenerate_treeedges-Tuple{PhyloNetworks.HybridNetwork}"><code>shrinkdegenerate_treeedges</code></a> to remove degenerate internal tree nodes, and <a href="#PhyloGaussianBeliefProp.hasdegenerate-Tuple{PhyloNetworks.HybridNetwork}"><code>hasdegenerate</code></a> to check if <code>net</code> still has degenerate nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/utils.jl#L97-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.allocatebeliefs-Union{Tuple{T2}, Tuple{T1}, Tuple{NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Vector{PhyloNetworks.Node}, MetaGraphsNext.MetaGraph{T1, Graph} where Graph&lt;:Graphs.AbstractGraph{T1}, PhyloGaussianBeliefProp.EvolutionaryModel{T2}}} where {T1, T2}" href="#PhyloGaussianBeliefProp.allocatebeliefs-Union{Tuple{T2}, Tuple{T1}, Tuple{NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Vector{PhyloNetworks.Node}, MetaGraphsNext.MetaGraph{T1, Graph} where Graph&lt;:Graphs.AbstractGraph{T1}, PhyloGaussianBeliefProp.EvolutionaryModel{T2}}} where {T1, T2}"><code>PhyloGaussianBeliefProp.allocatebeliefs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocatebeliefs(tbl, taxa, nodevector_preordered, clustergraph,
                 evolutionarymodel)</code></pre><p>Tuple <code>(beliefs, (node2cluster, node2family, node2degen, cluster2nodes))</code> with:</p><ul><li><code>beliefs</code>: vector of beliefs, canonical or generalized as appropriate, initialized to the constant function exp(0)=1, one for each cluster then one for each sepset in <code>clustergraph</code>.</li><li><code>node2cluster</code>: vector mapping each node to the cluster it is assigned to: <code>node2cluster[i]</code> is the index of the cluster to which was assigned the family for node of preorder index <code>i</code>.</li><li><code>node2family</code>: vector mapping each node to its node family. Each node is represented by its preorder index. A family is represented as a vector of preorder indices: [child, parent1, ...].</li><li><code>node2fixed</code>: vector of booleans, indicating for each node if its value is fixed, either because it&#39;s the root and is assumed fixed by the model, or because it&#39;s a tip with data (and any missing values removed from scope).</li><li><code>node2degen</code>: vector mapping each node to a boolean indicating if its distribution is deterministic given its parents (e.g. if all of its parent edges 0 length under a BM with no extra variance).</li><li><code>cluster2nodes</code>: vector mapping each cluster to the nodes (represented by their preorder index) whose families are assigned to the cluster.</li></ul><p><code>tbl</code> is used to know which leaf in <code>net</code> has data for which trait, so as to remove from the scope each variable without data below it. <code>taxa</code> should be a vector with taxon names in the same order as they come in the table of data <code>tbl</code>. The root is removed from scope if the evolutionary model has a fixed root: so as to use the model&#39;s fixed root value as data if the root as zero prior variance.</p><p>Warnings:</p><ul><li>This function might need to be re-run to re-do allocation if:<ul><li>the data changed: different number of traits, or different pattern of</li></ul>missing data at the tips<ul><li>the model changed: with the root changed from fixed to random, see</li></ul><a href="#PhyloGaussianBeliefProp.init_beliefs_allocate_atroot!-Union{Tuple{T}, Tuple{Any, Any, Any, PhyloGaussianBeliefProp.EvolutionaryModel{T}, Any, Any, Any}} where T"><code>init_beliefs_allocate_atroot!</code></a> in that case</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L441-L477">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.assign!-Union{Tuple{T}, Tuple{Dict{T, Array{Vector{T}, 1}}, Vector{T}, T}} where T&lt;:Integer" href="#PhyloGaussianBeliefProp.assign!-Union{Tuple{T}, Tuple{Dict{T, Array{Vector{T}, 1}}, Vector{T}, T}} where T&lt;:Integer"><code>PhyloGaussianBeliefProp.assign!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assign!(bucket, new_minibucket, max_minibucket_size)</code></pre><p>Merge <code>new_minibucket</code> with one of the minibuckets contained in <code>bucket</code> (in order of decreasing size) subject to the constraint that the resulting minibucket does not exceed <code>max_minibucket_size</code>. If this is not possible, then <code>new_minibucket</code> is added to <code>bucket</code> as a new minibucket. The bucket should be represented as a dictionary: minibucket_size =&gt; vector of minibuckets of that size, where each minibucket is itself represented as a vector of indices.</p><p>Output:</p><ul><li>(<code>resulting_minibucket</code>, <code>minibucket_merged_into</code>) if a successful merge is found</li><li>(<code>new_minibucket</code>, []) otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L690-L704">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.assignfactors!-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector{B}, PhyloGaussianBeliefProp.EvolutionaryModel, NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Vector{PhyloNetworks.Node}, Any, Any, Any}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}" href="#PhyloGaussianBeliefProp.assignfactors!-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector{B}, PhyloGaussianBeliefProp.EvolutionaryModel, NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Vector{PhyloNetworks.Node}, Any, Any, Any}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>PhyloGaussianBeliefProp.assignfactors!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assignfactors!(beliefs,
               evolutionarymodel, columntable, taxa,
               nodevector_preordered, node2cluster, node2family)</code></pre><p>Initialize cluster beliefs prior to belief propagation, by assigning each factor to one cluster. Sepset beliefs are reset to 1. There is one factor for each node v: the density of X_v conditional on its parent X_pa(v) if v is not the root, or the prior density for X_root.</p><ul><li>For each leaf, the factor is reduced by absorbing the evidence for that leaf,</li></ul><p>that is, the data found in <code>columntable</code>, whose rows should be ordered consistent with <code>taxa</code></p><ul><li>For each leaf, missing trait values are removed from scope.</li><li>For each internal node, any trait not in scope (e.g. if all descendant leaves</li></ul><p>are missing a value for this trait) is marginalized out of the factor.</p><p>Assumptions:</p><ul><li>In <code>beliefs</code>, cluster beliefs come first and sepset beliefs come last, as when</li></ul><p>created by <a href="#PhyloGaussianBeliefProp.allocatebeliefs-Union{Tuple{T2}, Tuple{T1}, Tuple{NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Vector{PhyloNetworks.Node}, MetaGraphsNext.MetaGraph{T1, Graph} where Graph&lt;:Graphs.AbstractGraph{T1}, PhyloGaussianBeliefProp.EvolutionaryModel{T2}}} where {T1, T2}"><code>allocatebeliefs</code></a></p><p><code>beliefs</code> is modified in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L763-L785">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.average_energy" href="#PhyloGaussianBeliefProp.average_energy"><code>PhyloGaussianBeliefProp.average_energy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">average_energy!(ref::AbstractBelief, target::AbstractFactor)
average_energy!(ref::AbstractBelief, Jₜ, hₜ, gₜ)
average_energy(Jᵣ::Union{LA.Cholesky,PDMat}, μᵣ, Jₜ, hₜ, gₜ)</code></pre><p>Average energy (i.e. negative expected log) of a <code>target</code> canonical form with parameters <code>(Jₜ, hₜ, gₜ)</code> with respect to a normalized non-degenerate reference canonical form <code>ref</code> with parameters <code>(Jᵣ, hᵣ)</code>. The reference distribution is normalized, so specifying <code>gᵣ</code> is unnecessary. When the target canonical form is also normalized and non-degenerate, this is equal to their cross-entropy:</p><pre><code class="nohighlight hljs">H(fᵣ, fₜ) = - Eᵣ(log fₜ) = - ∫ fᵣ log fₜ .</code></pre><p><code>ref</code> is assumed to be non-degenerate, that is, <code>Jᵣ</code> should be positive definite.</p><p><code>average_energy!</code> modifies the reference belief by updating <code>ref.μ</code> to J⁻¹h. It calls <code>average_energy</code> after a cholesky decomposition of <code>ref.J</code>, stored in <code>Jᵣ</code>: see <a href="#PhyloGaussianBeliefProp.getcholesky_μ!"><code>getcholesky_μ!</code></a>.</p><p><strong>Calculation:</strong></p><p>ref: f(x) = C(x | Jᵣ, hᵣ, _) is the density of 𝒩(μ=Jᵣ⁻¹hᵣ, Σ=Jᵣ⁻¹)   target: C(x | Jₜ, hₜ, gₜ) = exp( - (1/2)x&#39;Jₜx + hₜ&#39;x + gₜ )</p><pre><code class="nohighlight hljs">E[-log C(X | Jₜ, hₜ, gₜ)] where X ∼ C(Jᵣ, hᵣ, _)
= 0.5 (μᵣ&#39;Jₜ μᵣ + tr(Jᵣ⁻¹Jₜ)) - hₜ&#39;μᵣ - gₜ</code></pre><p>With empty vectors and matrices (J&#39;s of dimension 0×0 and h&#39;s of length 0), the result is simply: - gₜ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/score.jl#L74-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.average_energy!-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractFactor}" href="#PhyloGaussianBeliefProp.average_energy!-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractFactor}"><code>PhyloGaussianBeliefProp.average_energy!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">average_energy!(ref::AbstractBelief, target::AbstractFactor)
average_energy!(ref::AbstractBelief, Jₜ, hₜ, gₜ)
average_energy(Jᵣ::Union{LA.Cholesky,PDMat}, μᵣ, Jₜ, hₜ, gₜ)</code></pre><p>Average energy (i.e. negative expected log) of a <code>target</code> canonical form with parameters <code>(Jₜ, hₜ, gₜ)</code> with respect to a normalized non-degenerate reference canonical form <code>ref</code> with parameters <code>(Jᵣ, hᵣ)</code>. The reference distribution is normalized, so specifying <code>gᵣ</code> is unnecessary. When the target canonical form is also normalized and non-degenerate, this is equal to their cross-entropy:</p><pre><code class="nohighlight hljs">H(fᵣ, fₜ) = - Eᵣ(log fₜ) = - ∫ fᵣ log fₜ .</code></pre><p><code>ref</code> is assumed to be non-degenerate, that is, <code>Jᵣ</code> should be positive definite.</p><p><code>average_energy!</code> modifies the reference belief by updating <code>ref.μ</code> to J⁻¹h. It calls <code>average_energy</code> after a cholesky decomposition of <code>ref.J</code>, stored in <code>Jᵣ</code>: see <a href="#PhyloGaussianBeliefProp.getcholesky_μ!"><code>getcholesky_μ!</code></a>.</p><p><strong>Calculation:</strong></p><p>ref: f(x) = C(x | Jᵣ, hᵣ, _) is the density of 𝒩(μ=Jᵣ⁻¹hᵣ, Σ=Jᵣ⁻¹)   target: C(x | Jₜ, hₜ, gₜ) = exp( - (1/2)x&#39;Jₜx + hₜ&#39;x + gₜ )</p><pre><code class="nohighlight hljs">E[-log C(X | Jₜ, hₜ, gₜ)] where X ∼ C(Jᵣ, hᵣ, _)
= 0.5 (μᵣ&#39;Jₜ μᵣ + tr(Jᵣ⁻¹Jₜ)) - hₜ&#39;μᵣ - gₜ</code></pre><p>With empty vectors and matrices (J&#39;s of dimension 0×0 and h&#39;s of length 0), the result is simply: - gₜ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/score.jl#L74-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.betheclustergraph-Tuple{PhyloNetworks.HybridNetwork}" href="#PhyloGaussianBeliefProp.betheclustergraph-Tuple{PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.betheclustergraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">betheclustergraph(net)</code></pre><p>See <a href="#PhyloGaussianBeliefProp.Bethe"><code>Bethe</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L468-L472">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.branch_actualization-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.EvolutionaryModel{T}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}} where T" href="#PhyloGaussianBeliefProp.branch_actualization-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.EvolutionaryModel{T}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}} where T"><code>PhyloGaussianBeliefProp.branch_actualization</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branch_actualization(obj::EvolutionaryModel, edge::PN.Edge) 
branch_displacement(obj::EvolutionaryModel,  edge::PN.Edge)
branch_precision(obj::EvolutionaryModel,     edge::PN.Edge)
branch_variance(obj::EvolutionaryModel,      edge::PN.Edge)
branch_logdet(obj::EvolutionaryModel,        edge::PN.Edge, precision::AbstractMatrix)
branch_transition_qωjg(obj::EvolutionaryModel,    edge)
branch_transition_qωv!(q, obj::EvolutionaryModel, edge)</code></pre><p>Under the most general linear Gaussian model, X₀ given X₁ is Gaussian with conditional mean q X₁ + ω and conditional variance Σ independent of X₁. <code>branch_actualization</code>, <code>branch_displacement</code> and <code>branch_variance</code> return, respectively, q, ω and Σ. <code>branch_precision</code> and <code>branch_variance</code> should return a matrix of symmetric type. <code>branch_variance</code> defaults to the inverse of <code>branch_precision</code>. <code>branch_logdet</code> defaults to g = -0.5*log(|2πΣ|), the log normalizing constant of the Gaussian density in the traditional form. <code>branch_transition_*</code> return or modify in place the corresponding transition matrices.</p><p>Under a Brownian motion, we have q=I, ω=0, and conditional variance t*R where R is the model&#39;s variance rate and t the branch length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L122-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.branch_displacement" href="#PhyloGaussianBeliefProp.branch_displacement"><code>PhyloGaussianBeliefProp.branch_displacement</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branch_actualization(obj::EvolutionaryModel, edge::PN.Edge) 
branch_displacement(obj::EvolutionaryModel,  edge::PN.Edge)
branch_precision(obj::EvolutionaryModel,     edge::PN.Edge)
branch_variance(obj::EvolutionaryModel,      edge::PN.Edge)
branch_logdet(obj::EvolutionaryModel,        edge::PN.Edge, precision::AbstractMatrix)
branch_transition_qωjg(obj::EvolutionaryModel,    edge)
branch_transition_qωv!(q, obj::EvolutionaryModel, edge)</code></pre><p>Under the most general linear Gaussian model, X₀ given X₁ is Gaussian with conditional mean q X₁ + ω and conditional variance Σ independent of X₁. <code>branch_actualization</code>, <code>branch_displacement</code> and <code>branch_variance</code> return, respectively, q, ω and Σ. <code>branch_precision</code> and <code>branch_variance</code> should return a matrix of symmetric type. <code>branch_variance</code> defaults to the inverse of <code>branch_precision</code>. <code>branch_logdet</code> defaults to g = -0.5*log(|2πΣ|), the log normalizing constant of the Gaussian density in the traditional form. <code>branch_transition_*</code> return or modify in place the corresponding transition matrices.</p><p>Under a Brownian motion, we have q=I, ω=0, and conditional variance t*R where R is the model&#39;s variance rate and t the branch length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L122-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.branch_precision" href="#PhyloGaussianBeliefProp.branch_precision"><code>PhyloGaussianBeliefProp.branch_precision</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branch_actualization(obj::EvolutionaryModel, edge::PN.Edge) 
branch_displacement(obj::EvolutionaryModel,  edge::PN.Edge)
branch_precision(obj::EvolutionaryModel,     edge::PN.Edge)
branch_variance(obj::EvolutionaryModel,      edge::PN.Edge)
branch_logdet(obj::EvolutionaryModel,        edge::PN.Edge, precision::AbstractMatrix)
branch_transition_qωjg(obj::EvolutionaryModel,    edge)
branch_transition_qωv!(q, obj::EvolutionaryModel, edge)</code></pre><p>Under the most general linear Gaussian model, X₀ given X₁ is Gaussian with conditional mean q X₁ + ω and conditional variance Σ independent of X₁. <code>branch_actualization</code>, <code>branch_displacement</code> and <code>branch_variance</code> return, respectively, q, ω and Σ. <code>branch_precision</code> and <code>branch_variance</code> should return a matrix of symmetric type. <code>branch_variance</code> defaults to the inverse of <code>branch_precision</code>. <code>branch_logdet</code> defaults to g = -0.5*log(|2πΣ|), the log normalizing constant of the Gaussian density in the traditional form. <code>branch_transition_*</code> return or modify in place the corresponding transition matrices.</p><p>Under a Brownian motion, we have q=I, ω=0, and conditional variance t*R where R is the model&#39;s variance rate and t the branch length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L122-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.branch_variance" href="#PhyloGaussianBeliefProp.branch_variance"><code>PhyloGaussianBeliefProp.branch_variance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branch_actualization(obj::EvolutionaryModel, edge::PN.Edge) 
branch_displacement(obj::EvolutionaryModel,  edge::PN.Edge)
branch_precision(obj::EvolutionaryModel,     edge::PN.Edge)
branch_variance(obj::EvolutionaryModel,      edge::PN.Edge)
branch_logdet(obj::EvolutionaryModel,        edge::PN.Edge, precision::AbstractMatrix)
branch_transition_qωjg(obj::EvolutionaryModel,    edge)
branch_transition_qωv!(q, obj::EvolutionaryModel, edge)</code></pre><p>Under the most general linear Gaussian model, X₀ given X₁ is Gaussian with conditional mean q X₁ + ω and conditional variance Σ independent of X₁. <code>branch_actualization</code>, <code>branch_displacement</code> and <code>branch_variance</code> return, respectively, q, ω and Σ. <code>branch_precision</code> and <code>branch_variance</code> should return a matrix of symmetric type. <code>branch_variance</code> defaults to the inverse of <code>branch_precision</code>. <code>branch_logdet</code> defaults to g = -0.5*log(|2πΣ|), the log normalizing constant of the Gaussian density in the traditional form. <code>branch_transition_*</code> return or modify in place the corresponding transition matrices.</p><p>Under a Brownian motion, we have q=I, ω=0, and conditional variance t*R where R is the model&#39;s variance rate and t the branch length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L122-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.calibrate!" href="#PhyloGaussianBeliefProp.calibrate!"><code>PhyloGaussianBeliefProp.calibrate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calibrate!(beliefs::ClusterGraphBelief, schedule, niterations=1;
    auto::Bool=false, info::Bool=false,
    verbose::Bool=true,
    update_residualnorm::Bool=true,
    update_residualkldiv::Bool=false)</code></pre><p>Propagate messages in postorder then preorder for each tree in the <code>schedule</code> list, for <code>niterations</code>. Each schedule &quot;tree&quot; should be a tuple of 4 vectors as output by <a href="#PhyloGaussianBeliefProp.spanningtree_clusterlist-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}"><code>spanningtree_clusterlist</code></a>, where each vector provides the parent/child label/index of an edge along which to pass a message, and where these edges are listed in preorder. For example, the parent of the first edge is taken to be the root of the schedule tree. Calibration is evaluated after each schedule tree is run, and said to be reached if all message residuals have a small norm, based on <a href="#PhyloGaussianBeliefProp.iscalibrated_residnorm-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}"><code>iscalibrated_residnorm</code></a>.</p><p>Output: <code>true</code> if calibration is reached, <code>false</code> otherwise.</p><p>Optional keyword arguments:</p><ul><li><code>auto</code>: If true, then belief updates are stopped after calibration is found to be reached. Otherwise belief updates continue for the full number of iterations.</li><li><code>info</code>: Is true, information is logged with the iteration number and schedule tree index when calibration is reached.</li><li><code>verbose</code>: log error messages about degenerate messages</li><li><code>update_residualnorm</code></li><li><code>update_residualkldiv</code></li></ul><p>See also: <a href="#PhyloGaussianBeliefProp.iscalibrated_residnorm-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}"><code>iscalibrated_residnorm</code></a> and <a href="#PhyloGaussianBeliefProp.iscalibrated_residnorm!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any, Real}} where T"><code>iscalibrated_residnorm!</code></a> for the tolerance and norm used by default, to declare calibration for a given sepset message (in 1 direction).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/calibration.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.calibrate!" href="#PhyloGaussianBeliefProp.calibrate!"><code>PhyloGaussianBeliefProp.calibrate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calibrate!(beliefs::ClusterGraphBelief, scheduletree::Tuple,
    verbose::Bool=true, up_resnorm::Bool=true, up_reskldiv::Bool=false)</code></pre><p>Propagate messages along the <code>scheduletree</code>, in postorder then preorder: see <a href="#PhyloGaussianBeliefProp.propagate_1traversal_postorder!"><code>propagate_1traversal_postorder!</code></a>.</p><p>Output: <code>true</code> if all message residuals have a small norm, based on <a href="#PhyloGaussianBeliefProp.iscalibrated_residnorm-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}"><code>iscalibrated_residnorm</code></a>, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/calibration.jl#L62-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.calibrate_exact_cliquetree!-Union{Tuple{B}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief{B}, Any, Vector{PhyloNetworks.Node}, NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Any}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}" href="#PhyloGaussianBeliefProp.calibrate_exact_cliquetree!-Union{Tuple{B}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief{B}, Any, Vector{PhyloNetworks.Node}, NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Any}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>PhyloGaussianBeliefProp.calibrate_exact_cliquetree!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calibrate_exact_cliquetree!(beliefs::ClusterGraphBelief,
    schedule,
    nodevector_preordered,
    tbl::Tables.ColumnTable, taxa::AbstractVector,
    evolutionarymodel_name)</code></pre><p>For a Brownian Motion with a fixed root, compute the maximum likelihood estimate of the prior mean at the root and the restricted maximum likelihood (REML) estimate of the variance/covariance rate matrix using analytical formulas relying on belief propagation, using the data in <code>tbl</code> at leaves in the network. These estimates are for the model with a prior variance of 0 at the root, that is, a root state equal to the prior mean.</p><p>output: <code>(bestmodel, loglikelihood_score)</code> where <code>bestmodel</code> is an evolutionary model created by <code>evolutionarymodel_name</code>, containing the estimated model parameters.</p><p>assumptions:</p><ul><li><code>taxa</code> should list the taxon names in the same order in which they come in the rows of <code>tbl</code>.</li><li><code>schedule</code> should provide a schedule to transmit messages between beliefs in <code>beliefs</code> (containing clusters first then sepsets). This schedule is assumed to traverse a clique tree for the input phylogeny, with the root cluster containing the root of the phylogeny in its scope.</li><li><code>nodevector_preordered</code> should list the nodes in this phylogeny, in preorder.</li><li><code>beliefs</code> should be of size and scope consistent with <code>evolutionarymodel_name</code> and data in <code>tbl</code>.</li><li>a leaf should either have complete data, or be missing data for all traits.</li></ul><p>Steps:</p><ol><li>Calibrate <code>beliefs</code> in place according to the <code>schedule</code>, under a model with an infinite prior variance at the root.</li><li>Estimate parameters analytically.</li><li>Re-calibrate <code>beliefs</code>, to calculate the maximum log-likelihood of the fixed-root model at the estimated optimal parameters, again modifying <code>beliefs</code> in place. (Except that beliefs with the root node in scope are re-assigned to change their scoping dimension.)</li></ol><p>Warning: there is <em>no</em> check that the beliefs and schedule are consistent with each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/calibration.jl#L361-L403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.calibrate_optimize_cliquetree!" href="#PhyloGaussianBeliefProp.calibrate_optimize_cliquetree!"><code>PhyloGaussianBeliefProp.calibrate_optimize_cliquetree!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calibrate_optimize_cliquetree!(beliefs::ClusterGraphBelief, clustergraph,
    nodevector_preordered, tbl::Tables.ColumnTable, taxa::AbstractVector,
    evolutionarymodel_name, evolutionarymodel_startingparameters)</code></pre><p>Optimize model parameters using belief propagation along <code>clustergraph</code>, assumed to be a clique tree for the input network, whose nodes in preorder are <code>nodevector_preordered</code>. Optimization aims to maximize the likelihood of the data in <code>tbl</code> at leaves in the network. The taxon names in <code>taxa</code> should appear in the same order as they come in <code>tbl</code>. The parameters being optimized are the variance rate(s) and prior mean(s) at the root. The prior variance at the root is fixed.</p><p>The calibration does a postorder of the clique tree only, to get the likelihood at the root <em>without</em> the conditional distribution at all nodes, modifying <code>beliefs</code> in place. Therefore, if the distribution of ancestral states is sought, an extra preorder calibration would be required. Warning: there is <em>no</em> check that the cluster graph is in fact a clique tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/calibration.jl#L163-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.calibrate_optimize_clustergraph!" href="#PhyloGaussianBeliefProp.calibrate_optimize_clustergraph!"><code>PhyloGaussianBeliefProp.calibrate_optimize_clustergraph!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calibrate_optimize_clustergraph!(beliefs::ClusterGraphBelief, clustergraph,
    nodevector_preordered, tbl::Tables.ColumnTable, taxa::AbstractVector,
    evolutionarymodel_name, evolutionarymodel_startingparameters,
    max_iterations=100, regularizationfunction=regularizebeliefs_bycluster!)</code></pre><p>Same as <a href="#PhyloGaussianBeliefProp.calibrate_optimize_cliquetree!"><code>calibrate_optimize_cliquetree!</code></a> above, except that the user can supply an arbitrary <code>clustergraph</code> (including a clique tree) for the input network. Optimization aims to maximize the <a href="#PhyloGaussianBeliefProp.factored_energy-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}"><code>factored_energy</code></a> approximation to the ELBO for the log-likelihood of the data (which is also the negative Bethe <a href="#PhyloGaussianBeliefProp.free_energy-Union{Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief{B}}, Tuple{B}, Tuple{T}} where {T&lt;:Real, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>free_energy</code></a>). When <code>clustergraph</code> is a clique tree, the factored energy approximation is exactly equal to the ELBO and the log-likelihood.</p><p>Cluster beliefs are regularized using <a href="#PhyloGaussianBeliefProp.regularizebeliefs_bycluster!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>regularizebeliefs_bycluster!</code></a> by default (other options include <a href="#PhyloGaussianBeliefProp.regularizebeliefs_bynodesubtree!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>regularizebeliefs_bynodesubtree!</code></a>, <a href="#PhyloGaussianBeliefProp.regularizebeliefs_onschedule!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>regularizebeliefs_onschedule!</code></a>) before calibration. The calibration repeatedly loops through a minimal set of spanning trees (see <a href="#PhyloGaussianBeliefProp.spanningtrees_clusterlist-Union{Tuple{T}, Tuple{MetaGraphsNext.MetaGraph{T, Graph} where Graph&lt;:Graphs.AbstractGraph{T}, Vector{PhyloNetworks.Node}}} where T"><code>spanningtrees_clusterlist</code></a>) that covers all edges in the cluster graph, and does a postorder-preorder traversal for each tree. The loop runs till calibration is detected or till <code>max_iterations</code> have passed, whichever occurs first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/calibration.jl#L286-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.check_runningintersection-Tuple{MetaGraphsNext.MetaGraph, PhyloNetworks.HybridNetwork}" href="#PhyloGaussianBeliefProp.check_runningintersection-Tuple{MetaGraphsNext.MetaGraph, PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.check_runningintersection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_runningintersection(clustergraph, net)</code></pre><p>Vector of tuples. Each tuple is of the form <code>(nodelabel, istree)</code>, where <code>nodelabel::Symbol</code> is the label of a node in <code>net</code> and <code>istree</code> is true (false) if the node&#39;s cluster subgraph is (is not) a tree. This &quot;cluster subgraph&quot; for a given node is the subgraph of <code>clustergraph</code> induced by the clusters containing the node and by the edges whose sepset contain the node: see <a href="#PhyloGaussianBeliefProp.nodesubtree-Tuple{MetaGraphsNext.MetaGraph, Symbol}"><code>nodesubtree</code></a>.</p><p><code>clustergraph</code> satisfies the generalized <em>running-intersection</em> property if <code>istree</code> is true for all nodes in <code>net</code>.</p><p><strong>Warning</strong>:</p><ul><li>assumes that <code>net</code> has been preordered, and</li><li>does <em>not</em> check if <code>clustergraph</code> has been correctly constructed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L183-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.cliquetree-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T" href="#PhyloGaussianBeliefProp.cliquetree-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T"><code>PhyloGaussianBeliefProp.cliquetree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cliquetree(chordal_graph)</code></pre><p>Clique tree <code>U</code> for an input graph <code>g</code> assumed to be chordal (triangulated), e.g. using <a href="#PhyloGaussianBeliefProp.triangulate_minfill!-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T"><code>triangulate_minfill!</code></a>.   <strong>Warning</strong>: does <em>not</em> check that the graph is already triangulated.</p><ul><li>Each node in <code>U</code> is a maximal clique of <code>g</code> whose data is the tuple of vectors (node<em>labels, node</em>data) using the labels and data from <code>g</code>, with nodes sorted by decreasing data. If <code>g</code> was originally built from a phylogenetic network using <a href="#PhyloGaussianBeliefProp.moralize"><code>moralize</code></a>, then the nodes&#39; data are their preorder index, making them sorted in postorder within in each clique. The clique label is the concatenation of the node labels.</li><li>For each edge (clique1, clique2) in <code>U</code>, the edge data hold the sepset (separating set) information as a vector of node data, for nodes shared by both clique1 and clique2. In this sepset, nodes are sorted by decreasing data.</li></ul><p>Uses <code>maximal_cliques</code> and <code>kruskal_mst</code> (for min/maximum spanning trees) from <a href="https://juliagraphs.org/Graphs.jl/stable/">Graphs.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L738-L758">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.clustergraph" href="#PhyloGaussianBeliefProp.clustergraph"><code>PhyloGaussianBeliefProp.clustergraph</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clustergraph!(net, method)
clustergraph(net, method)</code></pre><p>Cluster graph <code>U</code> for an input network <code>net</code> and a <code>method</code> of cluster graph construction. The following methods are supported:</p><ul><li><a href="#PhyloGaussianBeliefProp.Bethe"><code>Bethe</code></a></li><li><a href="man/clustergraphs/#LTRIP"><code>LTRIP</code></a></li><li><a href="#PhyloGaussianBeliefProp.JoinGraphStructuring"><code>JoinGraphStructuring</code></a></li><li><a href="#PhyloGaussianBeliefProp.Cliquetree"><code>Cliquetree</code></a></li></ul><p>The first method pre-processes <code>net</code>, which may modify it in place, see <a href="#PhyloGaussianBeliefProp.preprocessnet!"><code>preprocessnet!</code></a>. The second method assumes that <code>net</code> is already pre-processed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L437-L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.clustergraph!-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.AbstractClusterGraphMethod}" href="#PhyloGaussianBeliefProp.clustergraph!-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.AbstractClusterGraphMethod}"><code>PhyloGaussianBeliefProp.clustergraph!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clustergraph!(net, method)
clustergraph(net, method)</code></pre><p>Cluster graph <code>U</code> for an input network <code>net</code> and a <code>method</code> of cluster graph construction. The following methods are supported:</p><ul><li><a href="#PhyloGaussianBeliefProp.Bethe"><code>Bethe</code></a></li><li><a href="man/clustergraphs/#LTRIP"><code>LTRIP</code></a></li><li><a href="#PhyloGaussianBeliefProp.JoinGraphStructuring"><code>JoinGraphStructuring</code></a></li><li><a href="#PhyloGaussianBeliefProp.Cliquetree"><code>Cliquetree</code></a></li></ul><p>The first method pre-processes <code>net</code>, which may modify it in place, see <a href="#PhyloGaussianBeliefProp.preprocessnet!"><code>preprocessnet!</code></a>. The second method assumes that <code>net</code> is already pre-processed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L437-L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.default_rootcluster-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}" href="#PhyloGaussianBeliefProp.default_rootcluster-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}"><code>PhyloGaussianBeliefProp.default_rootcluster</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_rootcluster(clustergraph, nodevector_preordered)</code></pre><p>Index of a cluster that contains the network&#39;s root, whose label is assumed to be <code>1</code> (preorder index). If multiple clusters contain the network&#39;s root, then one is chosen with the smallest number of taxa (leaves in the network).</p><p>For cluster with label <code>:lab</code>, its property <code>clustergraph[:lab][2]</code> should list the nodes in the cluster, by the index of each node in <code>nodevector_preordered</code> such that <code>1</code> corresponds to the network&#39;s root. Typically, this vector is <code>net.vec_node</code> after the network is preordered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L1010-L1021">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.default_rootcluster-Tuple{MetaGraphsNext.MetaGraph}" href="#PhyloGaussianBeliefProp.default_rootcluster-Tuple{MetaGraphsNext.MetaGraph}"><code>PhyloGaussianBeliefProp.default_rootcluster</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_rootcluster(clustergraph)</code></pre><p>Index of a cluster that contains the node with the smallest preorder index. If multiple clusters contain that node, then one is chosen that <em>only</em> has that node. If all clusters containing that node have more than 1 node, then a cluster is chosen containing a node with the second-smallest-preorder index.</p><p>For cluster with label <code>:lab</code>, its property <code>clustergraph[:lab][2]</code> should list the nodes in the cluster by their preorder index, sorted in decreasingly order (so the smallest is at the end).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L1031-L1042">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.dimension-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel}" href="#PhyloGaussianBeliefProp.dimension-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel}"><code>PhyloGaussianBeliefProp.dimension</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimension(m::EvolutionaryModel)</code></pre><p>Number of traits, e.g. 1 for univariate models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.divide!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.GeneralizedBelief}" href="#PhyloGaussianBeliefProp.divide!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.GeneralizedBelief}"><code>PhyloGaussianBeliefProp.divide!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">divide!(sepset::GeneralizedBelief, cluster_from::GeneralizedBelief)
divide!(sepset::CanonicalBelief, cluster_from::GeneralizedBelief)
divide!(sepset::CanonicalBelief, h, J, g)</code></pre><p>Divide an outgoing message by a sepset belief, return the canonical parameters of the quotient, and update the sepset belief to the message.</p><p>For the first two forms, the dividend is the message of <code>cluster_from</code>. For the third form, the canonical parameters of the message are specified directly (it is assumed in this case that the message is unconstrained by any linear dependencies among its variables). For the first form, the message of <code>sepset</code> is updated to the quotient. If the quotient is constrained (i.e. must be expressed as a generalized belief), then the canonical parameters of the unconstrained part (i.e. exponential quadratic part) are returned (i.e. Qh, QΛQᵀ, g).</p><p>Assumptions (not checked):</p><ul><li>Dividend and divisor are assumed to have matching scopes</li><li>The constraint rank for the divisor cannot exceed that of the dividend</li></ul><p>(i.e. cluster_from.kmsg[1] ≥ sepset.k[1]) for division to be well-defined</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefupdates.jl#L490-L511">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.entropy-Union{Tuple{Union{LinearAlgebra.Cholesky{T}, PDMats.PDMat{T, S} where S&lt;:AbstractMatrix{T}}}, Tuple{T}} where T&lt;:Real" href="#PhyloGaussianBeliefProp.entropy-Union{Tuple{Union{LinearAlgebra.Cholesky{T}, PDMats.PDMat{T, S} where S&lt;:AbstractMatrix{T}}}, Tuple{T}} where T&lt;:Real"><code>PhyloGaussianBeliefProp.entropy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">entropy(J::Cholesky)
entropy(J::AbstractMatrix)
entropy(belief::AbstractFactor)</code></pre><p>Entropy of a multivariate Gaussian distribution with precision matrix <code>J</code>, assumed to be square and symmetric (not checked). It is 0 if <code>J</code> is empty (of size 0×0). It may be <code>Inf</code> if <code>J</code> is semi-definite. The second version applies the first to the belief precision <code>belief.J</code>.</p><p><code>entropy</code> is defined for discrete distributions in <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#StatsBase.entropy">StatsBase.jl</a> and extended to Gaussian distributions in Distributions.jl around <a href="https://github.com/JuliaStats/Distributions.jl/blob/master/src/multivariate/mvnormal.jl#L95">here</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/score.jl#L43-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.extend!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.GeneralizedBelief}" href="#PhyloGaussianBeliefProp.extend!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.GeneralizedBelief}"><code>PhyloGaussianBeliefProp.extend!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extend!(cluster_to::GeneralizedBelief, sepset)
extend!(cluster_to::GeneralizedBelief, upind, Δh, ΔJ, Δg)
extend!(cluster_to::GeneralizedBelief, upind, R, c, g)</code></pre><p>Extend and match the scope of an incoming message to the scope of generalized belief <code>cluster_to</code> so that multiplication (see <a href="#PhyloGaussianBeliefProp.mult!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.GeneralizedBelief}"><code>mult!</code></a>) can be applied. The incoming message is extended within the message of <code>cluster_to</code>.</p><p>The first form applies when the incoming message is the message of <code>sepset</code>. The second form applies when the incoming message is non-deterministic with canonical parameters Δh, ΔJ, Δg. The third form applies when the incoming message is deterministic with constraint matrix R, offset c, and multiplicative constant exp(g) (i.e. exp(g)⋅δ(Rᵀx - c))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefupdates.jl#L284-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.factor_hybridnode-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.EvolutionaryModel{T}, AbstractVector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}}} where T" href="#PhyloGaussianBeliefProp.factor_hybridnode-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.EvolutionaryModel{T}, AbstractVector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}}} where T"><code>PhyloGaussianBeliefProp.factor_hybridnode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factor_hybridnode(evolutionarymodel, ts::AbstractVector, γs)
factor_tree_degeneratehybrid(model,  t0::Real,           γs)</code></pre><p>Canonical parameters <code>h,J,g</code> of factor ϕ(X₀, X₁, X₂, ...) from the evolutionary model for a hybrid node: where X₀ is the state at the hybrid node and X₁, X₂, ... the states of the parent nodes. <strong>Warning:</strong> <code>γs</code> is modified in placed, changed to <code>[1 -γs]</code>.</p><p>It is assumed that the conditional mean is a simple weighted average:</p><p><span>$E[X_0 | X_1, X_2, ...] = \sum_k \gamma_k X_k = q \mathrm{vec}(X_1,X_2,...) + \omega$</span></p><p>where q has one block for each parent, and each block is diagonal scalar: <span>$\gamma_k I_p$</span>. More complex models could consider adding a shift ω to the conditional mean.</p><p>If all the parent hybrid edges have length 0, then it is assumed that the model gives a degenerate distribution, with 0 conditional variance. More complex models could consider adding a hybrid conditional variance Σ.</p><ul><li>The first form assumes that at least 1 parent edge length is positive, with conditional variance <span>$\sum_k \gamma_k^2 V_k$</span> where <span>$V_k$</span> is the conditional variance from the kth parent edge.</li><li>The second form can be used in case all parent edges have 0 length, to integrate out the hybrid node state and the factor ϕ(X₀, X₁, X₂, ...) when X₀ is its <strong>child</strong> state, along an edge of length <code>t0</code> between the hybrid node and its child. This second form is appropriate when this hybrid&#39;s child is a tree node, and <code>t0&gt;0</code>.`</li></ul><p>In <code>h</code> and <code>J</code>, the first p coordinates are for the hybrid (or its child) and the last coordinates for the parents, in the same order in which the edge lengths and γs are given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L280-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.factor_root-Tuple{T} where T&lt;:PhyloGaussianBeliefProp.EvolutionaryModel" href="#PhyloGaussianBeliefProp.factor_root-Tuple{T} where T&lt;:PhyloGaussianBeliefProp.EvolutionaryModel"><code>PhyloGaussianBeliefProp.factor_root</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factor_root(m::EvolutionaryModel)</code></pre><p>Canonical parameters <code>h,J,g</code> of the prior density at the root, from model <code>m</code>. Assumes that <code>isrootfixed(m)</code> returns <code>false</code> (in which case the root value should be absorbed as evidence and the root removed from scope). More strongly, the root variance is assumed to be invertible, in particular, traits are all non-fixed at the root.</p><p>The prior is improper if the prior variance is infinite. In this case this prior is not a distribution (total probability ≠ 1) but is taken as the constant function 1, which corresponds to h,J,g all 0 (and an irrelevant mean).</p><p>If the root variance is not invertible (e.g., fixed root), this function fails and should never be called (see <code>isrootfixed</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L360-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.factor_treeedge-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel, PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#PhyloGaussianBeliefProp.factor_treeedge-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>PhyloGaussianBeliefProp.factor_treeedge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factor_treeedge(evolutionarymodel, edge)</code></pre><p>Canonical parameters <code>h,J,g</code> of factor ϕ(X0,X1) from the given evolutionary model along one edge, where X₀ is the state of the child node and X₁ the state of the parent node. In <code>h</code> and <code>J</code>, the first p coordinates are for the child and the last p for the parent, where p is the number of traits (determined by the model).</p><p>Under the most general linear Gaussian model, X₀ given X₁ is Gaussian with conditional mean q X₁ + ω and conditional variance Σ independent of X₁. The generic fallback method uses functions  <a href="#PhyloGaussianBeliefProp.branch_actualization-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.EvolutionaryModel{T}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}} where T"><code>branch_actualization</code></a> for q,  <a href="#PhyloGaussianBeliefProp.branch_displacement"><code>branch_displacement</code></a> for ω,  <a href="#PhyloGaussianBeliefProp.branch_precision"><code>branch_precision</code></a> for Σ⁻¹.</p><p>Under a Brownian motion, we have q=I, ω=0, and Σ=tR where R is the model&#39;s variance rate and t is the length of the branch. In that case, a specific (more efficient) method is implemented, and the default fallback is not used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L188-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.factored_energy-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}" href="#PhyloGaussianBeliefProp.factored_energy-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}"><code>PhyloGaussianBeliefProp.factored_energy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factored_energy(beliefs::ClusterGraphBelief)</code></pre><p>Factored energy functional for general cluster graphs (Koller &amp; Friedman 2009), which approximates the evidence lower bound (ELBO), a lower bound for the log-likelihood. It is also called the (negative) Bethe free energy in the context of factor graphs It is the sum of the cluster average energies and entropies, minus the sepset entropies. It is assumed but not checked that <code>beliefs</code> are calibrated (neighbor clusters and sepset beliefs are consistent, used as local marginals).</p><p>For a calibrated clique tree, the factored energy is equal to the log-likelihood. For a calibrated cluster graph, it can serve as as approximation.</p><p>output: tuple of 3 values, the 3rd being the factored energy: (average energy, approximate entropy, factored energy = -energy + entropy).</p><p>See also: <a href="#PhyloGaussianBeliefProp.free_energy-Union{Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief{B}}, Tuple{B}, Tuple{T}} where {T&lt;:Real, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>free_energy</code></a>, <a href="#PhyloGaussianBeliefProp.entropy-Union{Tuple{Union{LinearAlgebra.Cholesky{T}, PDMats.PDMat{T, S} where S&lt;:AbstractMatrix{T}}}, Tuple{T}} where T&lt;:Real"><code>entropy</code></a>, <a href="#PhyloGaussianBeliefProp.average_energy!-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractFactor}"><code>average_energy!</code></a></p><p><strong>References</strong></p><p>D. Koller and N. Friedman. <em>Probabilistic graphical models: principles and techniques</em>. MIT Press, 2009. ISBN 9780262013192.</p><p>D. M. Blei, A. Kucukelbir, and J. D. McAuliffe. Variational inference: A Review for Statisticians, Journal of the American statistical Association, 112:518, 859-877, 2017, doi: <a href="https://doi.org/10.1080/01621459.2017.1285773">10.1080/01621459.2017.1285773</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/score.jl#L119-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.free_energy-Union{Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief{B}}, Tuple{B}, Tuple{T}} where {T&lt;:Real, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}" href="#PhyloGaussianBeliefProp.free_energy-Union{Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief{B}}, Tuple{B}, Tuple{T}} where {T&lt;:Real, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>PhyloGaussianBeliefProp.free_energy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">free_energy(beliefs::ClusterGraphBelief)</code></pre><p>negative <a href="#PhyloGaussianBeliefProp.factored_energy-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}"><code>factored_energy</code></a> to approximate the negative log-likelihood. The approximation is exact on a clique tree after calibration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/score.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.getcholesky-Tuple{AbstractMatrix}" href="#PhyloGaussianBeliefProp.getcholesky-Tuple{AbstractMatrix}"><code>PhyloGaussianBeliefProp.getcholesky</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getcholesky(J::AbstractMatrix)</code></pre><p>Cholesky decomposition of J, assumed to be symmetric <em>positive</em> definite, stored as a <code>PDMat</code> object. Warning: PDMat is not a subtype of Cholesky. <a href="https://github.com/JuliaStats/PDMats.jl">PDMats.jl</a> is efficient for structured matrices (e.g diagonal or sparse) and has efficient methods for linear algebra, e.g. <code>\</code>, <code>invquad</code>, <code>X_invA_Xt</code> etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/score.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.getcholesky_μ!" href="#PhyloGaussianBeliefProp.getcholesky_μ!"><code>PhyloGaussianBeliefProp.getcholesky_μ!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getcholesky_μ(J::AbstractMatrix, h)
getcholesky_μ!(belief::AbstractFactor)</code></pre><p>Tuple <code>(Jchol, μ)</code> where <code>Jchol</code> is a cholesky representation of <code>J</code> or <code>belief.J</code> and <code>μ</code> is J⁻¹h, used to update <code>belief.μ</code> (by the second method).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/score.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.getcholesky_μ-Tuple{AbstractMatrix, Any}" href="#PhyloGaussianBeliefProp.getcholesky_μ-Tuple{AbstractMatrix, Any}"><code>PhyloGaussianBeliefProp.getcholesky_μ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getcholesky_μ(J::AbstractMatrix, h)
getcholesky_μ!(belief::AbstractFactor)</code></pre><p>Tuple <code>(Jchol, μ)</code> where <code>Jchol</code> is a cholesky representation of <code>J</code> or <code>belief.J</code> and <code>μ</code> is J⁻¹h, used to update <code>belief.μ</code> (by the second method).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/score.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.hasdegenerate-Tuple{PhyloNetworks.HybridNetwork}" href="#PhyloGaussianBeliefProp.hasdegenerate-Tuple{PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.hasdegenerate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hasdegenerate(net)</code></pre><p><code>true</code> if degenerate nodes remain in scope, that is, if there exists a tree edge of length 0, or if there exists a hybrid node with all parent edges of length 0 and with 2 or more children edges, or with 1 child edge of length 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/utils.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.hybridnode_displacement-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.EvolutionaryModel{T}, AbstractVector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}}} where T" href="#PhyloGaussianBeliefProp.hybridnode_displacement-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.EvolutionaryModel{T}, AbstractVector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}}} where T"><code>PhyloGaussianBeliefProp.hybridnode_displacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hybridnode_displacement(obj::EvolutionaryModel, parentedges::AbstractVector{PN.Edge})
hybridnode_precision(obj::EvolutionaryModel,    parentedges::AbstractVector{PN.Edge})
hybridnode_variance(obj::EvolutionaryModel,     parentedges::AbstractVector{PN.Edge})</code></pre><p>Under the most general weighted average Gaussian model, X₀ given its parents X₁, X₂, ... is Gaussian with conditional mean the weighted average of the parents plus a displacement vector ω and conditional variance Σ independent of X₁, X₂, ... . The weights are given by the inheritance probabilities contained in the <code>PN.Edge</code> objects. <code>hybridnode_displacement</code> and <code>hybridnode_variance</code> return, respectively, ω and Σ.</p><p><code>hybridnode_variance</code> and <code>hybridnode_precision</code> should return a matrix of symmetric type. <code>hybridnode_precision</code> defaults to the inverse of <code>hybridnode_variance</code>. <code>hybridnode_displacement</code> and <code>hybridnode_variance</code> default to a vector or matrix of zeros. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L251-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.hybridnode_precision" href="#PhyloGaussianBeliefProp.hybridnode_precision"><code>PhyloGaussianBeliefProp.hybridnode_precision</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hybridnode_displacement(obj::EvolutionaryModel, parentedges::AbstractVector{PN.Edge})
hybridnode_precision(obj::EvolutionaryModel,    parentedges::AbstractVector{PN.Edge})
hybridnode_variance(obj::EvolutionaryModel,     parentedges::AbstractVector{PN.Edge})</code></pre><p>Under the most general weighted average Gaussian model, X₀ given its parents X₁, X₂, ... is Gaussian with conditional mean the weighted average of the parents plus a displacement vector ω and conditional variance Σ independent of X₁, X₂, ... . The weights are given by the inheritance probabilities contained in the <code>PN.Edge</code> objects. <code>hybridnode_displacement</code> and <code>hybridnode_variance</code> return, respectively, ω and Σ.</p><p><code>hybridnode_variance</code> and <code>hybridnode_precision</code> should return a matrix of symmetric type. <code>hybridnode_precision</code> defaults to the inverse of <code>hybridnode_variance</code>. <code>hybridnode_displacement</code> and <code>hybridnode_variance</code> default to a vector or matrix of zeros. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L251-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.hybridnode_variance" href="#PhyloGaussianBeliefProp.hybridnode_variance"><code>PhyloGaussianBeliefProp.hybridnode_variance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hybridnode_displacement(obj::EvolutionaryModel, parentedges::AbstractVector{PN.Edge})
hybridnode_precision(obj::EvolutionaryModel,    parentedges::AbstractVector{PN.Edge})
hybridnode_variance(obj::EvolutionaryModel,     parentedges::AbstractVector{PN.Edge})</code></pre><p>Under the most general weighted average Gaussian model, X₀ given its parents X₁, X₂, ... is Gaussian with conditional mean the weighted average of the parents plus a displacement vector ω and conditional variance Σ independent of X₁, X₂, ... . The weights are given by the inheritance probabilities contained in the <code>PN.Edge</code> objects. <code>hybridnode_displacement</code> and <code>hybridnode_variance</code> return, respectively, ω and Σ.</p><p><code>hybridnode_variance</code> and <code>hybridnode_precision</code> should return a matrix of symmetric type. <code>hybridnode_precision</code> defaults to the inverse of <code>hybridnode_variance</code>. <code>hybridnode_displacement</code> and <code>hybridnode_variance</code> default to a vector or matrix of zeros. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L251-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.init_beliefs_allocate_atroot!-Union{Tuple{T}, Tuple{Any, Any, Any, PhyloGaussianBeliefProp.EvolutionaryModel{T}, Any, Any, Any}} where T" href="#PhyloGaussianBeliefProp.init_beliefs_allocate_atroot!-Union{Tuple{T}, Tuple{Any, Any, Any, PhyloGaussianBeliefProp.EvolutionaryModel{T}, Any, Any, Any}} where T"><code>PhyloGaussianBeliefProp.init_beliefs_allocate_atroot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_beliefs_allocate_atroot!(beliefs, factors, messageresiduals, model,
    node2family, cluster2nodes)</code></pre><p>Update the scope and re-allocate memory for cluster &amp; sepset <code>beliefs</code>, <code>factors</code> and <code>messageresiduals</code> to include or exclude the root, depending on whether the root variable is random or fixed in <code>model</code>. To change the dimension of canonical parameters μ,h,J, new memory is allocated and initialized to 0. This function can be used to update beliefs when the root model changes from fixed to non-fixed or vice-versa. It re-allocates less memory than <a href="#PhyloGaussianBeliefProp.allocatebeliefs-Union{Tuple{T2}, Tuple{T1}, Tuple{NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Vector{PhyloNetworks.Node}, MetaGraphsNext.MetaGraph{T1, Graph} where Graph&lt;:Graphs.AbstractGraph{T1}, PhyloGaussianBeliefProp.EvolutionaryModel{T2}}} where {T1, T2}"><code>allocatebeliefs</code></a> (which would need to be followed by <a href="#PhyloGaussianBeliefProp.init_factors_allocate-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector{B}, Integer}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>init_factors_allocate</code></a>) because clusters and sepsets that do not have the root are not modified.</p><p>Assumptions:</p><ul><li>all traits at the root have at least one descendant with non-missing data,</li><li>beliefs were previously initialized with a model that had the same number of traits as the current <code>model</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L639-L658">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.init_beliefs_reset!-Union{Tuple{AbstractVector{B}}, Tuple{B}, Tuple{T}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}" href="#PhyloGaussianBeliefProp.init_beliefs_reset!-Union{Tuple{AbstractVector{B}}, Tuple{B}, Tuple{T}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>PhyloGaussianBeliefProp.init_beliefs_reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_beliefs_reset!(beliefs::Vector{&lt;:AbstractBelief})</code></pre><p>Reset all beliefs (which can be cluster and/or sepset beliefs) so that they can later be re-initialized for different model parameters and re-calibrated, without re-allocating memory. For CanonicalBeliefs, all entries of h, J, g are zeroed, with μ left unchanged. For GeneralizedBeliefs, all entries of h, hmsg, Λ, Λmsg, g, gmsg, k, kmsg are zeroed. Q and Qmsg are set to the identity. μ, R, Rmsg, c, cmsg are left unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L696-L705">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.init_beliefs_reset_fromfactors!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}" href="#PhyloGaussianBeliefProp.init_beliefs_reset_fromfactors!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}"><code>PhyloGaussianBeliefProp.init_beliefs_reset_fromfactors!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_beliefs_reset_fromfactors!(beliefs::ClusterGraphBelief)</code></pre><p>Reset cluster beliefs to existing factors, and sepset beliefs to h=0, J=0, g=0</p><p>This is not used so far, as changing model parameters requires a reset of both factors and beliefs, done by <a href="#PhyloGaussianBeliefProp.assignfactors!-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector{B}, PhyloGaussianBeliefProp.EvolutionaryModel, NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Vector{PhyloNetworks.Node}, Any, Any, Any}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>assignfactors!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraphbeliefs.jl#L118-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.init_clustergraph-Tuple{Type{&lt;:Integer}, Symbol}" href="#PhyloGaussianBeliefProp.init_clustergraph-Tuple{Type{&lt;:Integer}, Symbol}"><code>PhyloGaussianBeliefProp.init_clustergraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_clustergraph(T::Type{&lt;:Integer}, clustergraph_method::Symbol)</code></pre><p><code>MetaGraph</code> with an empty base graph (0 vertices, 0 edges), meta-graph data <code>clustergraph_method</code>, edge-weight function counting the length of the edge-data vector, and the following types:</p><ul><li>vertex indices in the base graph: <code>T</code></li><li>vertex labels: <code>Symbol</code></li><li>vertex data: <code>Tuple{Vector{Symbol}, Vector{T}}</code> to hold information about the variables (nodes in phylogenetic network) in the cluster (vertex in cluster graph): node names as symbols, and node preorder indices</li><li>edge data: <code>Vector{T}</code> to hold information about the sepset: preorder index of nodes in the sepset.</li></ul><p>See packages <a href="https://juliagraphs.org/MetaGraphsNext.jl/dev/">MetaGraphsNext</a> and <a href="https://juliagraphs.org/Graphs.jl/dev/">Graphs</a>.</p><p>The empty graph above is of type <code>Graphs.SimpleGraphs.SimpleGraph{T}</code>: undirected, with vertex indices of type <code>T</code>. After addition of <code>n</code> vertices, the vertex indices range from 1 to <code>n</code>, technically in <code>Base.OneTo{T}(n)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L822-L844">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.init_factors_allocate-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector{B}, Integer}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}" href="#PhyloGaussianBeliefProp.init_factors_allocate-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector{B}, Integer}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>PhyloGaussianBeliefProp.init_factors_allocate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_factors_allocate(beliefs::AbstractVector{&lt;:AbstractBelief}, nclusters::Integer)</code></pre><p>Vector of <code>nclusters</code> factors of type <a href="#PhyloGaussianBeliefProp.ClusterFactor-Union{Tuple{PhyloGaussianBeliefProp.CanonicalBelief{T, Vlabel, P, V} where {Vlabel&lt;:(AbstractVector), P&lt;:AbstractMatrix{T}, V&lt;:AbstractVector{T}}}, Tuple{T}} where T"><code>ClusterFactor</code></a>, whose canonical parameters and metadata are initialized to be a copy of those in <code>beliefs</code>. Assumption: <code>beliefs[1:nclusters]</code> are cluster beliefs, and <code>beliefs[nclusters+1:end]</code> (if any) are sepset beliefs. This is not checked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L620-L627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.init_factors_frombeliefs!-Union{Tuple{B}, Tuple{Any, AbstractVector{B}}, Tuple{Any, AbstractVector{B}, Bool}} where B&lt;:PhyloGaussianBeliefProp.AbstractBelief" href="#PhyloGaussianBeliefProp.init_factors_frombeliefs!-Union{Tuple{B}, Tuple{Any, AbstractVector{B}}, Tuple{Any, AbstractVector{B}, Bool}} where B&lt;:PhyloGaussianBeliefProp.AbstractBelief"><code>PhyloGaussianBeliefProp.init_factors_frombeliefs!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_factors_frombeliefs!(
    factors,
    beliefs::AbstractVector{&lt;:CanonicalBelief},
    checkmetadata::Bool=false
)</code></pre><p>Reset all <code>factors</code> by copying h,J,g from <code>beliefs</code>. Assumption: the cluster beliefs match the factors exactly: for a valid factor index <code>i</code>, <code>beliefs[i]</code> is of cluster type and has the same dimension as <code>factors[i]</code>.</p><p>Set <code>checkmetadata</code> to true to check that <code>beliefs[i]</code> and <code>factors[i]</code> have the same metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L732-L746">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!" href="#PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!"><code>PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_messagecalibrationflags_reset!(beliefs::ClusterGraphBelief, reset_kl=true)</code></pre><p>Reset all non-empty message residuals in <code>beliefs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraphbeliefs.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Bool}} where T" href="#PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Bool}} where T"><code>PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_messagecalibrationflags_reset!(mr::AbstractResidual, reset_kl::Bool)</code></pre><p>For a non-empty message residual <code>mr</code>, reset its <code>iscalibrated_*</code> flags to false, and if <code>reset_kl</code> is true, reset its <code>kldiv</code> to -1. Its <code>ΔJ</code> and <code>Δh</code> fields are <em>not</em> reset here, because they are overwritten during a belief propagation step. Nothing is done for empty messages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L964-L972">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.init_messageresidual_allocate-Union{Tuple{T}, Tuple{Array{PhyloGaussianBeliefProp.AbstractBelief{T}, 1}, Any}} where T&lt;:Real" href="#PhyloGaussianBeliefProp.init_messageresidual_allocate-Union{Tuple{T}, Tuple{Array{PhyloGaussianBeliefProp.AbstractBelief{T}, 1}, Any}} where T&lt;:Real"><code>PhyloGaussianBeliefProp.init_messageresidual_allocate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_messageresidual_allocate(beliefs::Vector{B}, nclusters)</code></pre><p>Dictionary of <code>2k</code> residuals of type <a href="#PhyloGaussianBeliefProp.MessageResidual"><code>MessageResidual</code></a>, whose canonical parameters (Δh,ΔJ) are initialized using <a href="#PhyloGaussianBeliefProp.MessageResidual"><code>MessageResidual</code></a>, to be of the same size as sepsets in <code>beliefs</code>, where <code>k</code> is <code>length(beliefs) - nclusters</code>. Assumption: the first <code>nclusters</code> beliefs are cluster beliefs, and the next <code>k</code> beliefs are sepset beliefs. This is not checked.</p><p>The sepset for edge <code>(label1,label2)</code> is associated with 2 messages, for the 2 directions in which beliefs can be propagated along the edge. The keys for these messages are <code>(label1,label2)</code> and <code>(label2,label1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L926-L938">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.inscope_onenode-Tuple{Any, PhyloGaussianBeliefProp.AbstractBelief}" href="#PhyloGaussianBeliefProp.inscope_onenode-Tuple{Any, PhyloGaussianBeliefProp.AbstractBelief}"><code>PhyloGaussianBeliefProp.inscope_onenode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inscope_onenode(node_label, b:AbstractBelief)</code></pre><p>AbstractVector: view of the row vector in <code>b</code>&#39;s inscope matrix corresponding to node <code>node_label</code>, indicating whether a trait at that node is in scope or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L317-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.integratebelief!-Tuple{PhyloGaussianBeliefProp.CanonicalBelief}" href="#PhyloGaussianBeliefProp.integratebelief!-Tuple{PhyloGaussianBeliefProp.CanonicalBelief}"><code>PhyloGaussianBeliefProp.integratebelief!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integratebelief!(belief::CanonicalBelief)
integratebelief!(belief::GeneralizedBelief)
integratebelief(h,J,g)</code></pre><p>(μ, norm) from fully integrating the belief. The first two forms update <code>belief.μ</code>.</p><p>For a canonical belief, μ = J⁻¹h and norm = g + (log|2πJ⁻¹| + hᵀJ⁻¹h)/2. For a generalized belief, μ = QΛ⁻¹h + Rc and norm = g + (log|2πΛ⁻¹| + hᵀΛ⁻¹h)/2. μ is the mean of x, where x is the inscope of <code>belief</code>. norm is the normalization constant from integrating out x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefupdates.jl#L155-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.integratebelief!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph, Any}" href="#PhyloGaussianBeliefProp.integratebelief!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph, Any}"><code>PhyloGaussianBeliefProp.integratebelief!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integratebelief!(obj::ClusterGraphBelief, beliefindex)
integratebelief!(obj::ClusterGraphBelief)
integratebelief!(obj::ClusterGraphBelief, clustergraph, nodevector_preordered)</code></pre><p><code>(μ,g)</code> from fully integrating the object belief indexed <code>beliefindex</code>. This belief is modified, with its <code>belief.μ</code>&#39;s values updated to those in <code>μ</code>.</p><p>The second method uses the first sepset containing a single node. This is valid if the beliefs are fully calibrated (including a pre-order traversal), but invalid otherwise. The third method uses the default cluster containing the root, see <a href="#PhyloGaussianBeliefProp.default_rootcluster-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}"><code>default_rootcluster</code></a>. This is valid if the same cluster was used as the root of the cluster graph, if this graph is a clique tree, and after a post-order traversal to start the calibration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraphbeliefs.jl#L174-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.iscalibrated_kl!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}} where T" href="#PhyloGaussianBeliefProp.iscalibrated_kl!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}} where T"><code>PhyloGaussianBeliefProp.iscalibrated_kl!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iscalibrated_kl!(res::AbstractResidual, atol=1e-5)</code></pre><p>True if the KL divergence stored in <code>res.kldiv</code> is within <code>atol</code> of 0; false otherwise. <code>res.iscalibrated_kl</code> is modified accordingly. This KL divergence should have been previously calculated: between a sepset belief, equal to the message that was passed most recently, and its belief just prior to passing that message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L1005-L1013">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.iscalibrated_residnorm!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any, Real}} where T" href="#PhyloGaussianBeliefProp.iscalibrated_residnorm!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any, Real}} where T"><code>PhyloGaussianBeliefProp.iscalibrated_residnorm!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iscalibrated_residnorm!(res::AbstractResidual, atol=1e-5, p::Real=Inf)</code></pre><p>True if the canonical parameters <code>res.Δh</code> and <code>res.ΔJ</code> of the message residual have <code>p</code>-norm within <code>atol</code> of 0; false otherwise. <code>res.iscalibrated_resid</code> is updated accordingly.</p><p>With <code>p</code> infinite, the max norm is used by default, meaning that <code>res.Δh</code> and <code>res.ΔJ</code> should be close to 0 element-wise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L984-L993">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.iscalibrated_residnorm-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}" href="#PhyloGaussianBeliefProp.iscalibrated_residnorm-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}"><code>PhyloGaussianBeliefProp.iscalibrated_residnorm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iscalibrated_residnorm(beliefs::ClusterGraphBelief)
iscalibrated_kl(beliefs::ClusterGraphBelief)</code></pre><p>True if all edges in the cluster graph have calibrated messages in both directions, in that their latest message residuals have norm close to 0 (<code>residnorm</code>) or KL divergence close to 0 between the message received and prior sepset belief. False if not all edges have calibrated messages.</p><p>This condition is sufficient but not necessary for calibration.</p><p>Calibration was determined for each individual message residual by <a href="#PhyloGaussianBeliefProp.iscalibrated_residnorm!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any, Real}} where T"><code>iscalibrated_residnorm!</code></a> and <a href="#PhyloGaussianBeliefProp.iscalibrated_kl!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}} where T"><code>iscalibrated_kl!</code></a> using some tolerance value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraphbeliefs.jl#L153-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.isdegenerate-Tuple{PhyloNetworks.Node}" href="#PhyloGaussianBeliefProp.isdegenerate-Tuple{PhyloNetworks.Node}"><code>PhyloGaussianBeliefProp.isdegenerate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdegenerate(node)</code></pre><p><code>true</code> if <em>all</em> parent edges of <code>node</code> have length 0, <code>false</code> otherwise. Intended for hybrid nodes, as tree edges of length 0 should be suppressed before trait evolution analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/utils.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.isdegenerate_extendedfamily_covered-Tuple{Integer, Vector{&lt;:Integer}, Any, Any, Any}" href="#PhyloGaussianBeliefProp.isdegenerate_extendedfamily_covered-Tuple{Integer, Vector{&lt;:Integer}, Any, Any, Any}"><code>PhyloGaussianBeliefProp.isdegenerate_extendedfamily_covered</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdegenerate_extendedfamily_covered(nodeindex, clustermembers,
    node2family, node2degen, node2fixed)</code></pre><p>Check for the absence of an intermediate node in a degenerate extended family, for an input node <code>v</code> represented by its preorder index, looking at its ancestors in the input cluster <code>C</code> represented by its members, a vector of node preorder indices.</p><p>Output: tuple of 2 booleans <code>(b1,b2)</code> where</p><ul><li><code>b1</code> is true if <code>v</code> is degenerate conditional on its ancestors that are present in <code>C</code>, false otherwise (e.g. <code>v</code> is not degenerate conditional on its parents, or if none of its parents are in <code>C</code>)</li><li><code>b2</code> is true if <code>C</code> is a &quot;good cover&quot; for <code>v</code> in the following sense: either <code>v</code> is not generate given its ancestors in <code>C</code>, or <code>C</code> contains all of <code>v</code>&#39;s parents.</li></ul><p>By <code>v</code> is &quot;degenerate&quot; we mean that its distribution is deterministic, taking as value a linear (or affine) combination of its ancestor(s)&#39; value(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/utils.jl#L129-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.isdegenerate_extendedfamily_covered-Tuple{Vector{&lt;:Integer}, Vararg{Any}}" href="#PhyloGaussianBeliefProp.isdegenerate_extendedfamily_covered-Tuple{Vector{&lt;:Integer}, Vararg{Any}}"><code>PhyloGaussianBeliefProp.isdegenerate_extendedfamily_covered</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdegenerate_extendedfamily_covered(clustermembers, args...)
isdegenerate_extendedfamily_covered(cluster2nodes, args...)</code></pre><p>Boolean: <code>true</code> if for each node <code>v</code> in the input cluster <code>C</code>, <code>C</code> contains all intermediate nodes in the degenerate extended family of <code>v</code>. <code>false</code> if this property fails for one or more node <code>v</code> in <code>C</code>.</p><p>The first method considers a single cluster, containing <code>clustermembers</code>. The second method consider all clusters in a cluster graph, and returns true if <em>all</em> clusters meet the condition.</p><p>We say that <code>C</code> contains all intermediate ancestors for <code>v</code> in <code>v</code>&#39;s degenerate extended family if:</p><ul><li>for any set of ancestors <code>A ⊆ C</code> such that <code>v</code> is degenerate conditional on <code>A</code>,</li><li>for any <code>p</code> intermediate between <code>A</code> and <code>v</code> (that is <code>p</code> is a descendant of <code>A</code> and ancestor of <code>v</code>),</li><li>then we have that <code>p ∈ C</code>.</li></ul><p>We check that this condition holds for all nodes <code>v</code> in <code>C</code> by checking, more simply, that for any <code>v</code> degenerate given its ancestors in <code>C</code>, all of <code>v</code>&#39;s parents are in <code>C</code>.</p><p>positional arguments <code>args...</code>: <code>node2family, node2degen, node2fixed</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/utils.jl#L173-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.isfamilypreserving-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, PhyloNetworks.HybridNetwork}} where T&lt;:Integer" href="#PhyloGaussianBeliefProp.isfamilypreserving-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, PhyloNetworks.HybridNetwork}} where T&lt;:Integer"><code>PhyloGaussianBeliefProp.isfamilypreserving</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isfamilypreserving(clusters, net)</code></pre><p>Tuple <code>(ispreserving, isfamily_incluster)</code>:</p><ol><li><code>ispreserving</code>: true (false) if <code>clusters</code> is (is not) family-preserving with respect to <code>net</code>, that is: if each node family (a node and all of its parents) in <code>net</code> is contained in at least 1 cluster in <code>clusters</code>. <code>clusters</code> should be a vector, where each element describes one cluster, given as a vector of preorder indices. Index <code>i</code> corresponds to node number <code>i</code> in <code>net</code> according the node pre-ordering: <code>net.vec_node[i]</code>.</li><li><code>isfamily_incluster</code>: vector of <code>BitVector</code>s. <code>isfamily_incluster[i][j]</code> is true (false) if the family of node <code>i</code> is (is not) fully contained in cluster [j]. <code>i</code> is taken as the preorder index of a node in <code>net</code>. <code>ispreserving</code> is true if every element (bit vector) in <code>isfamily_incluster</code>  contains at least 1 true value.</li></ol><p><strong>Warning</strong>: assumes that <code>net</code> is preordered, see <a href="https://JuliaPhylo.github.io/PhyloNetworks.jl/latest/lib/public/#PhyloNetworks.preorder!"><code>PhyloNetworks.preorder!</code></a>).</p><p>See also <a href="#PhyloGaussianBeliefProp.nodefamilies-Tuple{PhyloNetworks.HybridNetwork}"><code>nodefamilies</code></a> to get node families.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L148-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.ishybridsinglepositivechild-Tuple{PhyloNetworks.Node}" href="#PhyloGaussianBeliefProp.ishybridsinglepositivechild-Tuple{PhyloNetworks.Node}"><code>PhyloGaussianBeliefProp.ishybridsinglepositivechild</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ishybridsinglepositivechild(node)</code></pre><p><code>true</code> if <code>node</code> is a hybrid node with a single child edge of positive length. If it <a href="#PhyloGaussianBeliefProp.isdegenerate-Tuple{PhyloNetworks.Node}"><code>isdegenerate</code></a>) (all its parent edges have length 0) and if its child is a tree node, then it could be removed from scope: see <a href="#PhyloGaussianBeliefProp.unscope-Tuple{PhyloNetworks.Node}"><code>unscope</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/utils.jl#L18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.joingraph-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.JoinGraphStructuring}" href="#PhyloGaussianBeliefProp.joingraph-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.JoinGraphStructuring}"><code>PhyloGaussianBeliefProp.joingraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">joingraph(net, method::JoinGraphStructuring)</code></pre><p>See <a href="#PhyloGaussianBeliefProp.JoinGraphStructuring"><code>JoinGraphStructuring</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L600-L604">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.ltripclustergraph-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.LTRIP}" href="#PhyloGaussianBeliefProp.ltripclustergraph-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.LTRIP}"><code>PhyloGaussianBeliefProp.ltripclustergraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ltripclustergraph(net, method::LTRIP)</code></pre><p>See <a href="man/clustergraphs/#LTRIP"><code>LTRIP</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L525-L529">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.marginalize!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.AbstractBelief}" href="#PhyloGaussianBeliefProp.marginalize!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.AbstractBelief}"><code>PhyloGaussianBeliefProp.marginalize!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">marginalize!(cluster_from::GeneralizedBelief, sepset::AbstractBelief)
marginalize!(cluster_from::GeneralizedBelief, keep_index)</code></pre><p>Marginalize a generalized belief by integrating out one or more inscope variables of <code>cluster_from</code>. The first form integrates out variables that are not shared by an adjacent (this is not checked!) <code>sepset</code>. The second form integrates out variables at indices <code>keep_index</code>. The resulting marginal is stored in the message of <code>cluster_from</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefupdates.jl#L85-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.marginalize-Tuple{PhyloGaussianBeliefProp.AbstractFactor, Any}" href="#PhyloGaussianBeliefProp.marginalize-Tuple{PhyloGaussianBeliefProp.AbstractFactor, Any}"><code>PhyloGaussianBeliefProp.marginalize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">marginalize(belief::AbstractFactor, keep_index)
marginalize(h,J,g, keep_index, beliefmetadata)
marginalize(h,J,g, keep_index, integrate_index, beliefmetadata)</code></pre><p>Canonical form (h,J,g) of the input belief, after all variables except those at indices <code>keep_index</code> have been integrated out. If we use <code>I</code> and <code>S</code> subscripts to denote subvectors and submatrices at indices to integrate out (I: <code>integrate_index</code>) and indices to keep (S: save for sepset, <code>keep_index</code>) then the returned belief parameters are:</p><p><span>$h_S - J_{S,I} J_I^{-1} h_I$</span></p><p><span>$J_S - J_{S,I} J_I^{-1} J_{I,S}$</span></p><p>and</p><p><span>$g + (\log|2\pi J_I^{-1}| + h_I^{T} J_I^{-1} h_I)/2 .$</span></p><p>These operations fail if the Cholesky decomposition of <span>$J_I$</span> fails. In that case, an error of type <a href="#PhyloGaussianBeliefProp.BPPosDefException"><code>BPPosDefException</code></a> is thrown with a message about the <code>beliefmetadata</code>, which can be handled by downstream functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefupdates.jl#L24-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.moralize" href="#PhyloGaussianBeliefProp.moralize"><code>PhyloGaussianBeliefProp.moralize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moralize!(net::HybridNetwork, prefix=&quot;I&quot;)
moralize(net)</code></pre><p>Undirected graph <code>g</code> of type <a href="https://github.com/JuliaGraphs/MetaGraphsNext.jl">MetaGraph</a> with the same nodes as in <code>net</code>, labelled by their names in <code>net</code>, with extra edges to moralize the graph, that is, to connect any nodes with a common child. Node data, accessed as <code>g[:nodelabel]</code>, is their index in the network&#39;s preordering. Edge data, accessed as <code>g[:label1, :label2]</code> is a type to indicate if the edge was an original tree edge or hybrid edge, or added to moralize the graph. Another type, not used here, if for fill edges that may need to be added to triangulate <code>g</code> (make it chordal).</p><p>The first version modifies <code>net</code> to name its internal nodes (used as labels in <code>g</code>) and to create or update its node preordering, then calls the second version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L23-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.moralize!" href="#PhyloGaussianBeliefProp.moralize!"><code>PhyloGaussianBeliefProp.moralize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moralize!(net::HybridNetwork, prefix=&quot;I&quot;)
moralize(net)</code></pre><p>Undirected graph <code>g</code> of type <a href="https://github.com/JuliaGraphs/MetaGraphsNext.jl">MetaGraph</a> with the same nodes as in <code>net</code>, labelled by their names in <code>net</code>, with extra edges to moralize the graph, that is, to connect any nodes with a common child. Node data, accessed as <code>g[:nodelabel]</code>, is their index in the network&#39;s preordering. Edge data, accessed as <code>g[:label1, :label2]</code> is a type to indicate if the edge was an original tree edge or hybrid edge, or added to moralize the graph. Another type, not used here, if for fill edges that may need to be added to triangulate <code>g</code> (make it chordal).</p><p>The first version modifies <code>net</code> to name its internal nodes (used as labels in <code>g</code>) and to create or update its node preordering, then calls the second version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L23-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.mult!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.GeneralizedBelief}" href="#PhyloGaussianBeliefProp.mult!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.GeneralizedBelief}"><code>PhyloGaussianBeliefProp.mult!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mult!(cluster_to::GeneralizedBelief, sepset::GeneralizedBelief)
mult!(cluster_to::GeneralizedBelief)
mult!(cluster_to::GeneralizedBelief, upind, Δh, ΔJ, Δg)
mult!(cluster_to::GeneralizedBelief, upind, R, c, g)
mult!(cluster_to::CanonicalBelief, upind, Δh, ΔJ, Δg)</code></pre><p>Multiply an incoming message into a cluster belief. The incoming message is extended (see <a href="#PhyloGaussianBeliefProp.extend!-Tuple{PhyloGaussianBeliefProp.GeneralizedBelief, PhyloGaussianBeliefProp.GeneralizedBelief}"><code>extend!</code></a>) to the scope of the receiving cluster. The cluster belief is updated to the product.</p><p>The first form multiplies the message of <code>sepset</code> into <code>cluster_to</code>. The second form multiplies the message of <code>cluster_to</code> into its belief. The third and fourth form respectively multiply a non-deterministic and deterministic factor into <code>cluster_to</code>, by directly specifying canonical parameters or constraint parameters. The fifth form is analogous to the third one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefupdates.jl#L390-L406">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.nodefamilies-Tuple{PhyloNetworks.HybridNetwork}" href="#PhyloGaussianBeliefProp.nodefamilies-Tuple{PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.nodefamilies</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodefamilies(net)</code></pre><p>Vector <code>v</code> with elements of type <code>Vector{T}</code>. <code>v[i]</code> first lists <code>i</code>, the preorder index of node <code>net.vec_node[i]</code>, followed by the preorder index of all of this node&#39;s parents in <code>net</code>, sorted in decreasing order. Due to pre-ordering, all of the parents&#39; indices are listed after the node (their child) index. A given node and its parents is called a &quot;node family&quot;.</p><p><strong>Warning</strong>: <code>net</code> is assumed preordered, see <a href="#PhyloGaussianBeliefProp.preprocessnet!"><code>preprocessnet!</code></a> and <a href="https://JuliaPhylo.github.io/PhyloNetworks.jl/latest/lib/public/#PhyloNetworks.preorder!"><code>PhyloNetworks.preorder!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L123-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.nodesubtree-Tuple{MetaGraphsNext.MetaGraph, Symbol}" href="#PhyloGaussianBeliefProp.nodesubtree-Tuple{MetaGraphsNext.MetaGraph, Symbol}"><code>PhyloGaussianBeliefProp.nodesubtree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodesubtree(clustergraph::MetaGraph, node_symbol)
nodesubtree(clustergraph::MetaGraph, node_symbol, node_preorderindex)</code></pre><p>MetaGraph subgraph of <code>clustergraph</code> induced by the clusters and sepsets containing the node labelled <code>node_symbol</code> (of specified preorder index if known, not checked). If <code>clustergraph</code> satisfies the generalized running-intersection property, then this subgraph should be a tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L210-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.nodesubtree_clusterlist-Tuple{MetaGraphsNext.MetaGraph, Symbol}" href="#PhyloGaussianBeliefProp.nodesubtree_clusterlist-Tuple{MetaGraphsNext.MetaGraph, Symbol}"><code>PhyloGaussianBeliefProp.nodesubtree_clusterlist</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodesubtree_clusterlist(clustergraph::MetaGraph, nodesymbol)</code></pre><p>Spanning tree of the subgraph of <code>clustergraph</code> induced by the clusters and sepsets that contain the node labelled <code>nodesymbol</code>, see <a href="#PhyloGaussianBeliefProp.nodesubtree-Tuple{MetaGraphsNext.MetaGraph, Symbol}"><code>nodesubtree</code></a>. If <code>clustergraph</code> satisfies the generalized running-intersection property, then this subgraph should be a tree anyway, but this is not assumed (via extracting a spanning tree).</p><p>Output: tuple of 4 vectors describing a depth-first search traversal of the tree, starting from a cluster containing the node of smallest preorder index, as determined by <a href="#PhyloGaussianBeliefProp.default_rootcluster-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}"><code>default_rootcluster</code></a>. Each element in this tuple is a vector: see <a href="#PhyloGaussianBeliefProp.spanningtree_clusterlist-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}"><code>spanningtree_clusterlist</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L939-L952">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.params-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel}" href="#PhyloGaussianBeliefProp.params-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel}"><code>PhyloGaussianBeliefProp.params</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">params(m::EvolutionaryModel)</code></pre><p>Tuple of parameters, the same that can be used to construct the evolutionary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.params_optimize-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel}" href="#PhyloGaussianBeliefProp.params_optimize-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel}"><code>PhyloGaussianBeliefProp.params_optimize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">params_optimize(m::EvolutionaryModel)</code></pre><p>Tuple of transformed parameters for model <code>m</code>, in an unconstrained space that can be used for numerical optimization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.params_original-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel, AbstractArray}" href="#PhyloGaussianBeliefProp.params_original-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel, AbstractArray}"><code>PhyloGaussianBeliefProp.params_original</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">params_original(m::EvolutionaryModel, transformedparams::AbstractArray)</code></pre><p>Tuple of parameters for model <code>m</code> in the original space, corresponding to back-transformed  parameters of <code>transformedparams</code>, and that can be used as input to the model constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/evomodels/evomodels.jl#L98-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.parentinformation-Tuple{PhyloNetworks.Node, PhyloNetworks.HybridNetwork}" href="#PhyloGaussianBeliefProp.parentinformation-Tuple{PhyloNetworks.Node, PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.parentinformation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parentinformation(node, net)</code></pre><p>Tuple of (edge length, edge γ, index of parent node in <code>net.vec_node</code>) for all parent edges of <code>node</code>. Assumes that <code>net</code> has been preordered before.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/utils.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.preprocessnet!" href="#PhyloGaussianBeliefProp.preprocessnet!"><code>PhyloGaussianBeliefProp.preprocessnet!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">preprocessnet!(net::HybridNetwork, prefix=&quot;I&quot;)</code></pre><p>Create or update the pre-ordering of nodes in <code>net</code> using <code>PhyloNetworks.preorder!</code>, then name unnamed internal nodes, with names starting with <code>prefix</code>. Nodes in phylogenetic networks need to have names to build cluster graphs, in which a cluster contains network nodes. Pre-ordering is also used to traverse the network for building cluster graphs.</p><p>See <a href="#PhyloGaussianBeliefProp.clustergraph!-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.AbstractClusterGraphMethod}"><code>clustergraph!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.propagate_1traversal_postorder!" href="#PhyloGaussianBeliefProp.propagate_1traversal_postorder!"><code>PhyloGaussianBeliefProp.propagate_1traversal_postorder!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">propagate_1traversal_postorder!(beliefs::ClusterGraphBelief, spanningtree...)
propagate_1traversal_preorder!(beliefs::ClusterGraphBelief,  spanningtree...)</code></pre><p>Messages are propagated along the spanning tree, from the tips to the root by <code>propagate_1traversal_postorder!</code> and from the root to the tips by <code>propagate_1traversal_preorder!</code>.</p><p>The &quot;spanning tree&quot; should be a tuple of 4 vectors as output by <a href="#PhyloGaussianBeliefProp.spanningtree_clusterlist-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}"><code>spanningtree_clusterlist</code></a>, meant to list edges in preorder. Its nodes (resp. edges) should correspond to clusters (resp. sepsets) in <code>beliefs</code>: labels and indices in the spanning tree information should correspond to indices in <code>beliefs</code>. This condition holds if beliefs are produced on a given cluster graph and if the tree is produced by <a href="#PhyloGaussianBeliefProp.spanningtree_clusterlist-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}"><code>spanningtree_clusterlist</code></a> on the same graph.</p><p>Optional positional arguments after spanning tree, in this order (default value):</p><ul><li><code>verbose</code> (true): log error messages about degenerate messages that failed to be passed.</li><li><code>update_residualnorm</code> (true): to update each message residual&#39;s <code>iscalibrated_resid</code></li><li><code>update_residualkldiv</code> (false): to update each message residual&#39;s field <code>kldiv</code>: KL divergence between the new and old sepset beliefs, normalized to be considered as (conditional) distributions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/calibration.jl#L86-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.propagate_belief!-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractResidual}" href="#PhyloGaussianBeliefProp.propagate_belief!-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractResidual}"><code>PhyloGaussianBeliefProp.propagate_belief!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">propagate_belief!(cluster_to, sepset, cluster_from, residual)
propagate_belief!(cluster_to, sepset, cluster_from)</code></pre><p>Propagate a message from <code>cluster_from</code> to neighbor <code>cluster_to</code> through the connecting <code>sepset</code>, and update the beliefs of <code>sepset</code> and <code>cluster_to</code>. <code>cluster_from</code>&#39;s belief is marginalized to the inscope variables of <code>sepset</code> to produce the &quot;outgoing message&quot;. The outgoing message is divided by <code>sepset</code>&#39;s existing belief, and the quotient is received by <code>cluster_to</code> as the &quot;incoming message&quot;. Finally, <code>sepset</code>&#39;s belief is updated to the outgoing message, and <code>cluster_to</code>&#39;s belief is updated by multiplying in the incoming message.</p><p>The incoming message reflects the change in <code>sepset</code>&#39;s belief. We quantify this change by its canonical parameters. This is h, J, g if <code>sepset</code> is a canonical belief, or Qh, QΛQᵀ, g if it is a generalized belief (we ignore the constraint part).</p><p>The first form stores the potential and precision canonical parameters of the incoming message in <code>residual</code>, but returns nothing. The second form returns the canonical parameters of the incoming message, and dispatches on the types of <code>cluster_from</code>, <code>sepset</code> and <code>cluster_to</code>. There are 4 cases: (1) <code>sepset</code>, <code>cluster_to</code> and <code>cluster_from</code> are all canonical beliefs (2) <code>sepset</code>, <code>cluster_to</code> and <code>cluster_from</code> are all generalized beliefs (3) <code>sepset</code> and <code>cluster_from</code> are canonical beliefs, and <code>cluster_to</code> is a generalized belief (4) <code>sepset</code> and <code>cluster_to</code> are canonical beliefs, and <code>cluster_to</code> is a generalized belief</p><p><strong>Degeneracy</strong></p><p>Propagating a belief requires the precision of the <code>cluster_from</code>&#39;s belief (i.e. J if it is canonical, or QΛQᵀ if it is generalized) to have a non-degenerate submatrix J<em>I for the variables to be integrated out. Problems arise if J</em>I has one or more 0 eigenvalues, or infinite values (see <a href="#PhyloGaussianBeliefProp.marginalize-Tuple{PhyloGaussianBeliefProp.AbstractFactor, Any}"><code>marginalize</code></a>). If so, a <a href="#PhyloGaussianBeliefProp.BPPosDefException"><code>BPPosDefException</code></a> is returned <strong>but not thrown</strong>. Downstream functions should try &amp; catch these failures, and decide how to proceed. See <a href="#PhyloGaussianBeliefProp.regularizebeliefs_bycluster!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>regularizebeliefs_bycluster!</code></a> to reduce the prevalence of degeneracies.</p><p><strong>Warnings</strong></p><ul><li>the <code>μ</code> parameter is not updated</li><li>Does not check that <code>cluster_from</code> and <code>cluster_to</code> are of cluster type, or that <code>sepset</code> is of sepset type, but does check that the labels and scope of <code>sepset</code> are included in each cluster.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefupdates.jl#L589-L633">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.regularizebeliefs_1clustersepset!-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief, Any}" href="#PhyloGaussianBeliefProp.regularizebeliefs_1clustersepset!-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief, Any}"><code>PhyloGaussianBeliefProp.regularizebeliefs_1clustersepset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regularizebeliefs_1clustersepset!(cluster::AbstractBelief, sepset::AbstractBelief, ϵ)</code></pre><p>Modify beliefs of 1 cluster and 1 of sepset, assumed to be neighbors in a cluster graph (such that the sepset&#39;s scope is a subset of the cluster&#39;s scope) by adding ϵ to all diagonal elements of the sepset precision matrice <code>J</code> and to the corresponding diagonal elements of the cluster precision, so as to preserve the full graphical model.</p><p>Used by <a href="#PhyloGaussianBeliefProp.regularizebeliefs_bycluster!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>regularizebeliefs_bycluster!</code></a> and <a href="#PhyloGaussianBeliefProp.regularizebeliefs_onschedule!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>regularizebeliefs_onschedule!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraphbeliefs.jl#L251-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.regularizebeliefs_bycluster!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}" href="#PhyloGaussianBeliefProp.regularizebeliefs_bycluster!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>PhyloGaussianBeliefProp.regularizebeliefs_bycluster!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regularizebeliefs_bycluster!(beliefs::ClusterGraphBelief, clustergraph)
regularizebeliefs_bycluster!(beliefs::ClusterGraphBelief, clustergraph, cluster_label)</code></pre><p>Modify beliefs of cluster graph by adding positive values to some diagonal elements of precision matrices <code>J</code>, while preserving the full graphical model (product of cluster beliefs over product of sepset beliefs, invariant during belief propagation) so that all beliefs are non-degenerate.</p><p>This regularization could be done after initialization with <a href="#PhyloGaussianBeliefProp.assignfactors!-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector{B}, PhyloGaussianBeliefProp.EvolutionaryModel, NamedTuple{names, T} where {N, names, T&lt;:NTuple{N, AbstractVector}}, AbstractVector, Vector{PhyloNetworks.Node}, Any, Any, Any}} where {T, B&lt;:PhyloGaussianBeliefProp.AbstractBelief{T}}"><code>assignfactors!</code></a> for example.</p><p>The goal is that at each later step of belief propagation, the sending cluster has a non-degenerate (positive definite) precision matrix for the variables to be integrated, so that the message to be sent is well-defined (i.e. can be computed) and positive semidefinite.</p><p><strong>Algorithm</strong></p><p>For each cluster Ci (or for only for 1 cluster, labeled <code>cluster_label</code>):</p><ol><li>Find a regularization parameter adaptively for that cluster: ϵ = maximum absolute value of all entries in Ci&#39;s precision matrix J, and of the machine epsilon.   Then loop through its incident edges:</li><li>For each neighbor cluster Cj and associated sepset Sij, add ϵ &gt; 0 to the diagonal entries of Ci&#39;s precision matrix <code>J</code> corresponding to the traits in Sij.</li><li>To preserve the graphical model&#39;s joint distribution for the full set of variables (invariant during BP), the same ϵ is added to each diagonal entry of Sij&#39;s precision matrix.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraphbeliefs.jl#L204-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.regularizebeliefs_bynodesubtree!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}" href="#PhyloGaussianBeliefProp.regularizebeliefs_bynodesubtree!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>PhyloGaussianBeliefProp.regularizebeliefs_bynodesubtree!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regularizebeliefs_bynodesubtree!(beliefs::ClusterGraphBelief, clustergraph)</code></pre><p>Modify beliefs of cluster graph by adding positive values to some diagonal elements of precision matrices <code>J</code>, while preserving the full graphical model (product of cluster beliefs over product of sepset beliefs, invariant during belief propagation) so that all beliefs are non-degenerate.</p><p>The goal is the same as <a href="#PhyloGaussianBeliefProp.regularizebeliefs_bycluster!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>regularizebeliefs_bycluster!</code></a> and <a href="#PhyloGaussianBeliefProp.regularizebeliefs_onschedule!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>regularizebeliefs_onschedule!</code></a>, but the algorithm is different.</p><p><strong>Algorithm</strong></p><p>For each node (or variable) v:</p><ol><li>Consider the subgraph T of clusters &amp; edges that have v. If <code>clustergraph</code> has the generalized running-intersection property, this subgraph is a tree.</li><li>Root T at a cluster containing a node with the largest postorder index.</li><li>Find a regularization parameter adaptively for that node: ϵ = maximum absolute value of all entries in Ci&#39;s precision matrix J, and of the machine epsilon, over clusters Ci in T.</li><li>For each trait j, find the subtree Tj of clusters and sepsets that have trait j of node v in their scope.</li><li>For each cluster and sepset in Tj, except at its cluster root: add ϵ on the diagonal of their belief precision matrix <code>J</code> corresponding to trait j of node v.</li><li>Check that graphical model invariant is preserved, that is: for each trait j, ϵ was added to the same number of clusters as number of sepsets.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraphbeliefs.jl#L277-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.regularizebeliefs_onschedule!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}" href="#PhyloGaussianBeliefProp.regularizebeliefs_onschedule!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>PhyloGaussianBeliefProp.regularizebeliefs_onschedule!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regularizebeliefs_onschedule!(beliefs::ClusterGraphBelief, clustergraph)</code></pre><p>Modify beliefs of the cluster graph so that all beliefs are non-degenerate, by (1) adding positive values to some diagonal elements of precision matrices <code>J</code> while preserving the full graphical model, and (2) propagating messages by marginalizing cluster beliefs.</p><p>The goal is the same as <a href="#PhyloGaussianBeliefProp.regularizebeliefs_bycluster!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>regularizebeliefs_bycluster!</code></a> and <a href="#PhyloGaussianBeliefProp.regularizebeliefs_bynodesubtree!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}"><code>regularizebeliefs_bynodesubtree!</code></a>, but the algorithm is different.</p><p><strong>Algorithm</strong></p><p>The outcomes depends on a &quot;schedule&quot;, that is, on an order in which clusters are considered. Here, the method simply takes the order given by <code>labels(clustergraph)</code>. Mark all messages Ci → Cj as un-sent. For each cluster Ci in order:</p><ol><li>For each neighbor cluster Cj of Ci, if the message Cj → Ci has not been sent, then:<ul><li>add ϵ_i to the diagonal entries of sepset Sij&#39;s precision matrix Jij</li><li>add ϵ_i to the diagonal entries of Ci&#39;s precision matrix Ji that correspond to the inscope variables of Sij</li><li>mark Cj → Ci as sent.</li></ul>Notes:<ul><li>ϵ_i is taken as the maximum of all absolute values of entries in Ji, and of the square root of machine epsilon.</li><li>This is equivalent to &quot;sending&quot; a default message, that is not computed from Cj&#39;s belief, with diagonal precision matrix ϵ⋅I and other canonical parameters h=0, g=0.</li></ul></li><li>For each neighbor cluster Cj of Ci, if Ci → Cj has not been sent then<ul><li>send a message from Ci to Cj by marginalizing Ci&#39;s belief (that is, using belief propagation).</li><li>mark the message Ci → Cj as sent.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraphbeliefs.jl#L342-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.residual_kldiv!-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, PhyloGaussianBeliefProp.AbstractFactor{T}}} where T&lt;:Real" href="#PhyloGaussianBeliefProp.residual_kldiv!-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, PhyloGaussianBeliefProp.AbstractFactor{T}}} where T&lt;:Real"><code>PhyloGaussianBeliefProp.residual_kldiv!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">residual_kldiv!(residual::AbstractResidual, sepset::AbstractFactor,
    canonicalparams::Tuple)</code></pre><p>Update <code>residual.kldiv</code> with the <a href="https://en.wikipedia.org/wiki/Kullback-Leibler_divergence#Multivariate_normal_distributions">Kullback-Leibler</a> divergence between a message sent through a sepset (normalized to a probability distribution), and the sepset belief before the belief update (also normalized). <code>sepset</code> should contain the updated belief, and <code>residual</code> the difference in the <code>J</code> and <code>h</code> parameters due to the belief update (after - before), such that the previous belief is: <code>sepset</code> belief - <code>residual</code>. As a side product, <code>sepset.μ</code> is updated.</p><p>Output: <code>true</code> if the KL divergence is close to 0, <code>false</code> otherwise. See <a href="#PhyloGaussianBeliefProp.iscalibrated_kl!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}} where T"><code>iscalibrated_kl!</code></a> for the tolerance.</p><p>If the current or previous <code>sepset</code> belief is degenerate, in the sense that its precision matrix is not positive definite and the belief cannot be normalized to a proper distribution, then <code>residual</code> and <code>sepset</code> are not updated, and <code>false</code> is returned. No warning and no error is sent, because sepset beliefs are initialized at 0 and this case is expected to be frequent before enough messages are sent.</p><p><strong>Calculation:</strong></p><p>sepset after belief-update (i.e. message sent): C(x | Jₘ, hₘ, gₘ) ∝ density for     X ~ 𝒩(μ=Jₘ⁻¹hₘ, Σ=Jₘ⁻¹)   sepset before belief-update: C(x | Jₛ, hₛ, gₛ)   residual: ΔJ = Jₘ - Jₛ, Δh = hₘ - hₛ   p: dimension of X (number of variables: number of nodes * number of traits). Below, we use the notation Δg for the change in constants to normalize each message, which is <em>not</em> gₘ-gₛ because the stored beliefs are not normalized.</p><pre><code class="nohighlight hljs">KL(C(Jₘ, hₘ, _) || C(Jₛ, hₛ, _))
= Eₘ[log C(x | Jₘ,hₘ,_)/C(x | Jₛ,hₛ,_)] where x ∼ C(Jₘ,hₘ,_)
= Eₘ[-(1/2) x&#39;ΔJx + Δh&#39;x + Δg)]
= (  tr(JₛJₘ⁻¹) - p + (μₛ-μₘ)&#39;Jₛ(μₛ-μₘ) + log(det(Jₘ)/det(Jₛ))  ) /2</code></pre><p>See also: <a href="#PhyloGaussianBeliefProp.average_energy!-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractFactor}"><code>average_energy!</code></a>, which only requires the sepset belief to be positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L1018-L1059">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.scopeindex-Tuple{Any, PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief}" href="#PhyloGaussianBeliefProp.scopeindex-Tuple{Any, PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief}"><code>PhyloGaussianBeliefProp.scopeindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scopeindex(node_label, sepset::AbstractBelief, cluster::AbstractBelief)</code></pre><p>Tuple of 2 index vectors <code>(ind_in_sepset, ind_in_cluster)</code> in the sepset and in the cluster in-scope variables (that is, in the cluster&#39;s μ,h,J vectors and matrices) of the <em>shared</em> in-scope traits for node <code>node_label</code>, such that <code>sepset.μ[ind_in_sepset]</code> correspond to all the node&#39;s traits in the sepset scope and <code>cluster.μ[ind_in_cluster]</code> correspond to the same traits in the cluster scope, which may be a subset of all the node&#39;s traits in scope for that cluster. If not, an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L407-L417">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.scopeindex-Tuple{Integer, PhyloGaussianBeliefProp.AbstractBelief}" href="#PhyloGaussianBeliefProp.scopeindex-Tuple{Integer, PhyloGaussianBeliefProp.AbstractBelief}"><code>PhyloGaussianBeliefProp.scopeindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scopeindex(j::Integer, belief::AbstractBelief)</code></pre><p>Indices in the belief&#39;s μ,h,J vectors and matrices of the traits in scope for node indexed <code>j</code> in <code>nodelabels(belief)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L328-L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.scopeindex-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief}" href="#PhyloGaussianBeliefProp.scopeindex-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief}"><code>PhyloGaussianBeliefProp.scopeindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scopeindex(sepset::AbstractBelief, cluster::AbstractBelief)</code></pre><p>Indices <code>ind</code>, in the cluster in-scope variables (that is, in the cluster&#39;s μ,h,J vectors and matrices) of the sepset in-scope variables, such that <code>cluster.μ[ind]</code> correspond to the same variables as <code>sepset.μ</code>, for example. These sepset in-scope variables can be a subset of traits for each node in the sepset, as indicated by <code>inscope(sepset)</code>.</p><p>Warning: the labels in the sepset are assumed to be ordered as in the cluster.</p><p>An error is returned if <code>sepset</code> contains labels not in the <code>cluster</code>, or if a variable in the <code>sepset</code>&#39;s scope is not in scope in the <code>cluster</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L375-L388">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.scopeindex-Tuple{Union{Tuple, AbstractVector}, PhyloGaussianBeliefProp.AbstractBelief}" href="#PhyloGaussianBeliefProp.scopeindex-Tuple{Union{Tuple, AbstractVector}, PhyloGaussianBeliefProp.AbstractBelief}"><code>PhyloGaussianBeliefProp.scopeindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scopeindex(node_labels::Union{Tuple,AbstractVector}, belief::AbstractBelief)</code></pre><p>Indices in the belief&#39;s μ,h,J vectors and matrices of the variables for nodes labeled <code>node_labels</code>. The belief&#39;s <code>inscope</code> matrix of booleans says which node (column) and trait (row) is in the belief&#39;s scope. These variables are vectorized by stacking up columns, that is, listing all in-scope traits of the first node, then all in-scope traits of the second node etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/beliefs.jl#L344-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.shrinkdegenerate_treeedges-Tuple{PhyloNetworks.HybridNetwork}" href="#PhyloGaussianBeliefProp.shrinkdegenerate_treeedges-Tuple{PhyloNetworks.HybridNetwork}"><code>PhyloGaussianBeliefProp.shrinkdegenerate_treeedges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>shrinkdegenerate_treeedges(net::HybridNetwork)</p><p>Network obtained from <code>net</code> with any non-external tree edge of length 0 suppressed. Returns an error if any edge length is missing or negative, or if any γ is missing or non positive. It is assumed that γs sum to 1 across partner hybrid edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/utils.jl#L67-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.spanningtree_clusterlist-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}" href="#PhyloGaussianBeliefProp.spanningtree_clusterlist-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}"><code>PhyloGaussianBeliefProp.spanningtree_clusterlist</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spanningtree_clusterlist(clustergraph, root_index)
spanningtree_clusterlist(clustergraph, nodevector_preordered)</code></pre><p>Build the depth-first search spanning tree of the cluster graph, starting from the cluster indexed <code>root_index</code> in the underlying simple graph; find the associated topological ordering of the clusters (preorder); then return a tuple of these four vectors:</p><ol><li><code>parent_labels</code>: labels of the parents&#39; child clusters. The first one is the root.</li><li><code>child_labels</code>: labels of clusters in pre-order, except for the cluster  choosen to be the root.</li><li><code>parent_indices</code>: indices of the parent clusters</li><li><code>child_indices</code>: indices of the child clusters, listed in preorder as before.</li></ol><p>In the second version in which <code>root_index</code> is not provided, the root of the spanning tree is chosen to be a cluster that contains the network&#39;s root. If multiple clusters contain the network&#39;s root, then one is chosen containing the smallest number of taxa: see <a href="#PhyloGaussianBeliefProp.default_rootcluster-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}"><code>default_rootcluster</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L862-L880">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.spanningtrees_clusterlist-Union{Tuple{T}, Tuple{MetaGraphsNext.MetaGraph{T, Graph} where Graph&lt;:Graphs.AbstractGraph{T}, Vector{PhyloNetworks.Node}}} where T" href="#PhyloGaussianBeliefProp.spanningtrees_clusterlist-Union{Tuple{T}, Tuple{MetaGraphsNext.MetaGraph{T, Graph} where Graph&lt;:Graphs.AbstractGraph{T}, Vector{PhyloNetworks.Node}}} where T"><code>PhyloGaussianBeliefProp.spanningtrees_clusterlist</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spanningtrees_clusterlist(clustergraph, nodevector_preordered)</code></pre><p>Vector of spanning trees for <code>clustergraph</code>, that together cover all edges. Each spanning tree is specified as a tuple of 4 vectors describing a depth-first search traversal of the tree, starting from a cluster that contains the network&#39;s root, as in <a href="#PhyloGaussianBeliefProp.spanningtree_clusterlist-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}"><code>spanningtree_clusterlist</code></a>.</p><p>The spanning trees are iteratively obtained using Kruskal&#39;s minimum-weight spanning tree algorithm, with edge weights defined as the number of previous trees covering the edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L896-L907">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.triangulate_minfill!-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T" href="#PhyloGaussianBeliefProp.triangulate_minfill!-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T"><code>PhyloGaussianBeliefProp.triangulate_minfill!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triangulate_minfill!(graph)</code></pre><p>Ordering for node elimination, chosen to greedily minimize the number of fill edges necessary to eliminate the node (to connect all its neighbors with each other). Ties are broken by favoring the post-ordering of nodes. <code>graph</code> is modified with these extra fill edges, making it chordal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/clustergraph.jl#L79-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PhyloGaussianBeliefProp.unscope-Tuple{PhyloNetworks.Node}" href="#PhyloGaussianBeliefProp.unscope-Tuple{PhyloNetworks.Node}"><code>PhyloGaussianBeliefProp.unscope</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unscope(node)</code></pre><p><code>true</code> if <code>node</code> is a hybrid node with a single child edge of positive length, and if its child node is a tree node. If it <a href="#PhyloGaussianBeliefProp.isdegenerate-Tuple{PhyloNetworks.Node}"><code>isdegenerate</code></a>) (all its parent edges have length 0) then it could be removed from scope: see <a href="#PhyloGaussianBeliefProp.addtreenode_belowdegeneratehybrid!-Tuple{PhyloNetworks.HybridNetwork}"><code>addtreenode_belowdegeneratehybrid!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/PhyloGaussianBeliefProp.jl/blob/8a6bff974844495ddef70d8186c2237db964421b/src/utils.jl#L28-L36">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="man/installation/">Installation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Thursday 13 March 2025 02:06">Thursday 13 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
