var documenterSearchIndex = {"docs":
[{"location":"man/background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"man/background/#Trait-evolution-on-a-phylogeny","page":"Background","title":"Trait evolution on a phylogeny","text":"","category":"section"},{"location":"man/background/","page":"Background","title":"Background","text":"The evolution of molecular and phenotypic traits is commonly modeled using Markov processes along a rooted phylogeny.","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"For example, most models of continuous trait evolution on a phylogenetic tree are extensions of the Brownian motion (BM) to capture features such as:","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"evolutionary trends\nadaptation\nrate variation across lineages","category":"page"},{"location":"man/background/#Factoring-the-joint-model","page":"Background","title":"Factoring the joint model","text":"","category":"section"},{"location":"man/background/","page":"Background","title":"Background","text":"A Markov process along the phylogeny induces a joint distribution p_theta(x_1dotsx_m), with parameters theta, over all nodes (trait vectors) X_1dotsX_m.","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"p_theta(x_1dotsx_m) can also be factored as the product of conditional distributions phi_v for each node X_v, where phi_v=p_theta(x_vmid x_mathrmpa(v)) is the distribution of X_v given its parent(s) X_mathrmpa(v), e.g. X_mathrmpa(v)=beginbmatrix X_p_1  X_p_2endbmatrix:","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"p_theta(x_1dotsx_m) = prod_v=1^n phi_v","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"We focus on the case where all conditional distributions are linear Gaussian. That is, for each node X_v:","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"beginaligned\nX_vmid X_mathrmpa(v) sim mathcalN(omega_v+\nbmq_v X_mathrmpa(v)bmV_v) \nphi_v = (2pibmV_v)^-12exp(-x_v-(omega_v+bmq_v x_mathrmpa(v))_bmV_v^-12)\nendaligned","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"with trend vector omega_v, actualization matrix bmq_v, and covariance matrix bmV_v. For example, the BM on a phylogeny (and most of its extensions) satisfies this characterization [2].","category":"page"},{"location":"man/background/#Parameter-inference","page":"Background","title":"Parameter inference","text":"","category":"section"},{"location":"man/background/","page":"Background","title":"Background","text":"Typically, we observe the tips of the phylogeny X_1=mathrmx_1dotsX_n=mathrmx_n and use these data for parameter inference by optimizing the log-likelihood mathrmLL(theta)=logint p_theta(mathrmx_1dotsmathrmx_nx_n+1 dots x_m)dx_n+1dots dx_m:","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"widehattheta = argmax_theta  mathrmLL(theta)","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"For simpler models, it is possible to derive a closed-form expression for widehattheta by solving:","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"nabla_theta  mathrmLL(theta)_theta=widehattheta=0","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"for the zero of the log-likelihood gradient, and to compute it directly.","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"For more complicated models however, widehattheta must be obtained by iterative methods that evaluate mathrmLL(theta) over different parameter values.","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"In general, evaluating mathrmLL(theta) is costly as the size and complexity of the phylogeny grows.","category":"page"},{"location":"man/background/#BP-for-exact-inference","page":"Background","title":"BP for exact inference","text":"","category":"section"},{"location":"man/background/","page":"Background","title":"Background","text":"Belief propagation (BP) is a framework for efficiently computing various marginals of a joint distribution p_theta that can be factored into conditional distributions phi_vinPhi, where Phi denotes the full set of conditional distributions. We refer to the reference book by Koller and Friedman (2009) [3] for more background on BP, and only sketch the main steps involved here:","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"Construct a tree data structure called a clique tree (also known by junction tree, join tree, or tree decomposition), whose nodes mathcalC_i, called clusters, are subsets of X_1dotsX_m.\nEach conditional distribution is assigned (mapsto) to a cluster of the clique tree, and the product of all conditional distributions assigned to a cluster mathcalC_i initializes its belief beta_i = prod_phi_vmapstomathcalC_i phi_vinPhiphi_v\nEach cluster computes messages from its belief, and propagates these to its neighbor clusters to update their beliefs.","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"mathrmLL(theta) can be computed by passing messages according to a single postorder traversal of the clique tree,","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"An additional preorder traversal guarantees that every cluster belief is the corresponding marginal of p_theta. That is, every cluster belief reflects the conditional distribution of the cluster given the data.","category":"page"},{"location":"man/background/#Loopy-BP-for-approximate-inference","page":"Background","title":"Loopy BP for approximate inference","text":"","category":"section"},{"location":"man/background/","page":"Background","title":"Background","text":"A clique tree is a special case of a graph data structure called a cluster graph. In general, cluster graphs can be non-treelike with cycles.","category":"page"},{"location":"man/background/","page":"Background","title":"Background","text":"BP on a loopy cluster graph (i.e. a cluster graph with cycles), abbreviated as loopy BP, can approximate the likelihood and conditional distributions of the unobserved, ancestral nodes, and be more computationally efficient than BP.","category":"page"},{"location":"man/background/#References","page":"Background","title":"References","text":"","category":"section"},{"location":"man/background/","page":"Background","title":"Background","text":"I. Lazaridis, N. Patterson, A. Mittnik, G. Renaud, S. Mallick, K. Kirsanow, P. H. Sudmant, J. G. Schraiber, S. Castellano, M. Lipson and others. Ancient human genomes suggest three ancestral populations for present-day Europeans. Nature 513, 409–413 (2014).\n\n\n\nV. Mitov, K. Bartoszek, G. Asimomitis and T. Stadler. Fast likelihood calculation for multivariate Gaussian phylogenetic models with shifts. Theoretical Population Biology 131, 66–78 (2020).\n\n\n\nD. Koller and N. Friedman. Probabilistic graphical models: principles and techniques (MIT Press, 2009).\n\n\n\nN. F. Müller, K. E. Kistler and T. Bedford. A Bayesian approach to infer recombination patterns in coronaviruses. Nature communications 13, 4186 (2022).\n\n\n\nM. Lipson, I. Ribot, S. Mallick, N. Rohland, I. Olalde, N. Adamski, N. Broomandkhoshbacht, A. M. Lawson, S. López, J. Oppenheimer and others. Ancient West African foragers in the context of African population history. Nature 577, 665–670 (2020).\n\n\n\n","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"CurrentModule = PhyloGaussianBeliefProp","category":"page"},{"location":"man/evolutionary_models/#Evolutionary-models","page":"Evolutionary models","title":"Evolutionary models","text":"","category":"section"},{"location":"man/evolutionary_models/#Specifying-a-process","page":"Evolutionary models","title":"Specifying a process","text":"","category":"section"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"Each trait evolutionary model is specified as a linear Gaussian process, such as a BM or some extension of it, that evolves along the phylogeny.","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"Minimally, the user provides a variance rate Sigma, and a prior mean mu and variance bmV_rho for the root state X_rho. For example, bmV_rho=0 treats X_rho=mu as known, while bmV_rho=infty disregards all prior beliefs about X_rho.","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"For example, the univariate BM can be specified as:","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"julia> PGBP.UnivariateBrownianMotion(1, 0) # root variance v = 0 (fixed root)\nUnivariate Brownian motion\n\n- evolutionary variance rate σ2 :\n1.0\n- root mean μ :\n0.0\n\njulia> PGBP.UnivariateBrownianMotion(1, 0, Inf) # root variance v = Inf (improper prior)\nUnivariate Brownian motion\n\n- evolutionary variance rate σ2 :\n1.0\n- root mean μ :\n0.0\n- root variance v :\nInf","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"The multivariate BM is available to model multivariate traits. If the components of a multivariate trait evolve in an uncorrelated manner, then Sigma is a diagonal matrix and is specified its diagonal entries (e.g. MvDiagBrownianMotion). Otherwise, Sigma is potentially dense and is passed in whole (e.g. MvFullBrownianMotion).","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"julia> PGBP.MvDiagBrownianMotion([1, 0.5], [-1, 1]) # v = [0, 0]\nMultivariate Diagonal Brownian motion\n\n- evolutionary variance rates (diagonal values in the rate matrix): R :\n[1.0, 0.5]\n- root mean μ :\n[-1.0, 1.0]\n\njulia> PGBP.MvFullBrownianMotion([1 0.5; 0.5 1], [-1,1], [10^10 0; 0 10^10])\nMultivariate Brownian motion\n\n- evolutionary variance rate matrix: R :\n[1.0 0.5; 0.5 1.0]\n- root mean μ :\n[-1.0, 1.0]\n- root variance v :\n[1.0e10 0.0; 0.0 1.0e10]","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"Sigma can vary along the phylogeny. If path length tge 0 from the root represents evolutionary time, then the Early Burst (EB) model and Accelerating Rate (AC) model respectively allow Sigma to decay (b0) and grow (b0) along a time-consistent phylogeny:","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"Sigma(t) = Sigma_0exp(bt) text where  Sigma_0 = Sigma(0)","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"This model is not implemented at the moment.","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"Selection can be additionally modeled by the Ornstein-Uhlenbeck (OU) process, which allows a trait to diffuse with variance rate Sigma yet drift towards some optimal value theta (with selection \"strength\" bmA).","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"julia> PGBP.UnivariateOrnsteinUhlenbeck(2, 3, -2, 0, 0.4) # σ2=2, below showing γ2 = σ2/(2α)\nhomogeneous univariate Ornstein-Uhlenbeck\n\n- stationary evolutionary variance γ2 :\n0.3333333333333333\n- selection strength α :\n3.0\n- optimal value θ :\n-2.0\n- root mean μ :\n0.0\n- root variance v :\n0.4","category":"page"},{"location":"man/evolutionary_models/#Edge-factors","page":"Evolutionary models","title":"Edge factors","text":"","category":"section"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"After specifying the evolutionary model (e.g. m = PGBP.UnivariateBrownianMotion(1, 0)), it is eventually passed to init_beliefs_assignfactors! (see 4. Initialize cluster graph beliefs), which infers the conditional distribution for each node and assigns it to a cluster.","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"We refer to these conditional distributions as edge factors since they relate the states of a parent node and its child.","category":"page"},{"location":"man/evolutionary_models/#Hybrid-factors","page":"Evolutionary models","title":"Hybrid factors","text":"","category":"section"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"Each reticulation node X_h has multiple parents X_p_1dotsX_p_k, and is thus potentially associated with multiple edge factors. We reconcile these by modeling X_h as a weighted-average of its \"immediate parents\", the child states for each of these edge factors.","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"Imagine that we introduce k copies X_(p_1h)dotsX_(p_kh) of X_h, each of which descends from the corresponding X_p_i. Then X_h is modeled as a weighted-average of X_(p_1h)dotsX_(p_kh):","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"X_h = sum_i=1^k gamma_(p_ih) X_(p_ih)","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"where the inheritance weights gamma_(p_ih) are positive and sum to 1.","category":"page"},{"location":"man/evolutionary_models/","page":"Evolutionary models","title":"Evolutionary models","text":"Thus, each tree node is associated with an edge factor, and each hybrid node with a hybrid factor.","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"CurrentModule = PhyloGaussianBeliefProp\nDocTestSetup  = quote\n  using DataFrames, Tables, PhyloNetworks, PhyloGaussianBeliefProp;\n  const PGBP = PhyloGaussianBeliefProp;\nend","category":"page"},{"location":"man/message_schedules/#Message-schedules","page":"Message schedules","title":"Message schedules","text":"","category":"section"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"As described in 5. Propose a schedule from the cluster graph, we build a message schedule by calling spanningtrees_clusterlist on our given cluster graph (output by clustergraph!).","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"A schedule of messages can be visualized as a sequence of edge traversals (from sender to recipient) on the cluster graph.","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"Since the calibration of a cluster graph requires neighbor clusters to reach some state of agreement with each other, it is reasonable to expect that multiple messages may need to be sent back and forth on each edge. Thus, proper message schedules require that each edge is traversed in both directions, infinitely often (until stopping criteria are met).","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"spanningtrees_clusterlist satisfies the requirements of a proper message schedule by specifying a finite sequence of edge traversals that together account for all possible messages on the cluster graph. This sequence can then be repeated as needed. Specifically:","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"the sequence of edge traversals is returned as a collection of edge sets for different spanning trees of the cluster graph\neach edge set is ordered as a preorder traversal of a spanning tree","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"Each time calibrate! is called with a particular tree, it passes messages according to a postorder then preorder traversal of the tree.","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"Returning to the last few edges of the tree schedule from 5. Propose a schedule from the cluster graph:","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"julia> DataFrame(parent=sched[1][1], child=sched[1][2])[13:end,:] # last 4 edges of tree 1 in preorder\n4×2 DataFrame\n Row │ parent                             child                             \n     │ Symbol                             Symbol                            \n─────┼──────────────────────────────────────────────────────────────────────\n   1 │ AncientNorthEurasianI1I2NonAfric…  EasternNorthAfricanAncientNorthE…\n   2 │ EasternNorthAfricanAncientNorthE…  H1EasternNorthAfricanAncientNort…\n   3 │ H1EasternNorthAfricanAncientNort…  OngeEasternNorthAfrican\n   4 │ H1EasternNorthAfricanAncientNort…  KaritianaH1","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"According to a postorder, the first message to be sent is from KaritianaH1 to H1EasternNorthAfricanAncientNort…, followed by OngeEasternNorthAfrican to H1EasternNorthAfricanAncientNort… and so on.","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"An iteration of calibration refers to calibrate! being called once for each schedule tree in the collection.","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"Continuing with the code example from A heuristic, we:","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"increase the number of iterations of calibration to 100 (the default is 1)\ntell calibrate! to return once calibration is detected (auto=true)\nlog information on when calibration was detected (info=true)","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"julia> PGBP.init_beliefs_assignfactors!(b, m, tbl_x, df.taxon, net.nodes_changed); # reset to initial beliefs\n\njulia> PGBP.regularizebeliefs_bynodesubtree!(fgb, fg); # regularize by node subtree\n\njulia> PGBP.calibrate!(fgb, sched, 100; auto=true, info=true)\n[ Info: calibration reached: iteration 20, schedule tree 1\ntrue","category":"page"},{"location":"man/message_schedules/","page":"Message schedules","title":"Message schedules","text":"Similarly, during iterative optimization (e.g calibrate_optimize_clustergraph!), multiple iterations of calibration are run for each set of candidate parameter values (till beliefs are calibrated) to determine the associated factored energy.","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"CurrentModule = PhyloGaussianBeliefProp","category":"page"},{"location":"man/regularization/#Regularization","page":"Regularization","title":"Regularization","text":"","category":"section"},{"location":"man/regularization/#Ill-defined-messages","page":"Regularization","title":"Ill-defined messages","text":"","category":"section"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"Propagating a message tildemu_irightarrow j from a cluster mathcalC_i to its neighbor mathcalC_j involves 3 steps:","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"1. mathcalC_i's belief beta_i is marginalized over the sepset nodes mathcalS_ij:","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"tildemu_irightarrow j = intbeta_i d(mathcalC_isetminus\nmathcalS_ij)","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"2. The message tildemu_irightarrow j is divided by the current edge belief mu_ij, and the result is multiplied into mathcalC_j's belief beta_j:","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"beta_j leftarrow beta_jtildemu_irightarrow jmu_ij","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"3. The edge belief mu_ij is updated to the message just passed:","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"mu_ij leftarrow tildemu_irightarrow j","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"In the linear Gaussian setting, where each belief has the form exp(-x^topbmJx2 + h^topx + g), where x denotes its scope, these steps can be concisely expressed in terms of the (bmJhg) parameters of the beliefs involved.","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"Crucially, the precision matrix bmJ for beta_i has to be full-rank / invertible with respect to the nodes to be integrated out.","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"For example, if mathcalC_i=X_1X_2X_3, mathcalS_ij=X_1 and:","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"beta_i = expleft(-beginbmatrixx_1  x_2  x_3endbmatrix^topbmJ\nbeginbmatrixx_1  x_2  x_3endbmatrix2 +\nh^topbeginbmatrixx_1  x_2  x_3endbmatrix + gright) text where \nbmJ = beginmatrixx_1  x_2  x_3endmatrix\nbeginbmatrix1  -12  -12  -12  14  14 \n-12  14  14endbmatrix","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"then the 2times 2 submatrix of bmJ for mathcalC_isetminusmathcalS_ij=X_2X_3 (annotated above) consists only of 14s, is not full-rank, and thus tildemu_irightarrow j is ill-defined / cannot be computed.","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"On a clique tree, a schedule of messages that follows a postorder traversal of the tree (from the tip clusters to a root cluster) can always be computed.","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"On a loopy cluster graph however, it may be unclear how to find a schedule such that each message is well-defined, or if such a schedule even exists. This is a problem since a loopy cluster graph typically requires multiple traversals to reach convergence.","category":"page"},{"location":"man/regularization/#A-heuristic","page":"Regularization","title":"A heuristic","text":"","category":"section"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"One approach to deal with ill-defined messages is to skip their computation and proceed on with the schedule.","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"A more robust, yet simple, alternative is to regularize cluster beliefs by increasing some diagonal elements of their precision matrix so that the relevant submatrices are full-rank:","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":" beginmatrixx_1  x_2  x_3endmatrix\nbeginbmatrix1  -12  -12  -12  14  14 \n-12  14  14endbmatrix longrightarrow\nbeginbmatrix1  -12  -12  -12  14textcolorred+epsilon  14 \n-12  14  14textcolorred+epsilonendbmatrix","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"To maintain the probability model, the product of all cluster beliefs divided by the product of all edge beliefs must remain equal to the joint distribution  p_theta (this is satisfied after factor assignment, and everytime a message is passed).","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"Thus, each time a cluster belief is regularized, we \"balance\" this change by a similar modification to one or more associated edge beliefs. For example, if mathcalC_i above was connected to another sepset mathcalS_ik=X_2X_3 with bmJ=bm0 then we might do:","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":" beginmatrixx_2  x_3endmatrix\nbeginbmatrix0  0  0  0endbmatrix longrightarrow\nbeginbmatrix0textcolorred+epsilon  0  0 \ntextcolorred+epsilonendbmatrix","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"We provide several options for regularization below. A typical usage of these methods is after the initial assignment of factors.","category":"page"},{"location":"man/regularization/#By-cluster","page":"Regularization","title":"By cluster","text":"","category":"section"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"regularizebeliefs_bycluster! performs regularization separately from message passing.","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"The algorithm loops over each cluster. For each incident sepset, epsilon is added to all the diagonal entries of its precision, and to the corresponding diagonal entries of the cluster's precision.","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"Currently, calibrate_optimize_clustergraph! calls regularizebeliefs_bycluster! for each set of candidate parameter values, before calibration is run. Other options are likely to be available in future versions.","category":"page"},{"location":"man/regularization/#Along-node-subtrees","page":"Regularization","title":"Along node subtrees","text":"","category":"section"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"regularizebeliefs_bynodesubtree! performs regularization separately from message passing.","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"A node subtree of a cluster graph is the subtree induced by all clusters that contain that node.","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"The algorithm loops over each node subtree. For all edges and all but one cluster in a given node subtree, it adds epsilon to the diagonal entries of the precision matrix that correspond to that node.","category":"page"},{"location":"man/regularization/#On-a-schedule","page":"Regularization","title":"On a schedule","text":"","category":"section"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"regularizebeliefs_onschedule! interleaves regularization with message passing.","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"The algorithm loops over each cluster and tracks which messages have been sent:","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"Each cluster mathcalC_i is regularized only if it has not received a message from ge 1 of its neighbors.\nRegularization proceeds by adding epsilon to the diagonal entries of mathcalC_i's precision that correspond to the nodes in mathcalS_ij, and to all diagonal entries of mathcalS_ij's precision, if neighbor mathcalC_j has not sent a message to mathcalC_i.\nAfter being regularized, mathcalC_i sends a message to each neighbor for which it has not already done so.","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"The example below shows how regularization methods can help to minimize ill-defined messages. We use here a network from Lipson et al. (2020, Extended Data Fig. 4) [5], with degree-2 nodes suppressed and any resulting length 0 edges assigned length 1 (see lipson2020b_notes.jl), and follow the steps in Exact likelihood for fixed parameters:","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"julia> using DataFrames, Tables, PhyloNetworks, PhyloGaussianBeliefProp\n\njulia> const PGBP = PhyloGaussianBeliefProp;\n\njulia> net = readTopology(pkgdir(PGBP, \"test/example_networks\", \"lipson_2020b.phy\")); #  54 edges; 44 nodes: 12 tips, 11 hybrid nodes, 21 internal tree nodes.\n\njulia> preorder!(net)\n\njulia> df = DataFrame(taxon=tipLabels(net), # simulated using `simulate(net, ParamsBM(0, 1))` from PhyloNetworks\n               x=[0.431, 1.606, 0.72, 0.944, 0.647, 1.263, 0.46, 1.079, 0.877, 0.748, 1.529, -0.469]);\n\njulia> m = PGBP.UnivariateBrownianMotion(1, 0); # choose model: σ2 = 1.0, μ = 0.0 \n\njulia> fg = PGBP.clustergraph!(net, PGBP.Bethe()); # build factor graph\n\njulia> tbl_x = columntable(select(df, :x)); # trait data as column table\n\njulia> b = PGBP.init_beliefs_allocate(tbl_x, df.taxon, net, fg, m); # allocate memory for beliefs\n\njulia> PGBP.init_beliefs_assignfactors!(b, m, tbl_x, df.taxon, net.nodes_changed); # assign factors based on model\n\njulia> fgb = PGBP.ClusterGraphBelief(b); # wrap beliefs for message passing\n\njulia> sched = PGBP.spanningtrees_clusterlist(fg, net.nodes_changed); # generate schedule","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"Without regularization, errors indicating ill-defined messages (which are skipped) are returned when we run a single iteration of calibration:","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"julia> PGBP.calibrate!(fgb, sched); # there are ill-defined messages (which are skipped)\n┌ Error: belief H5I5I16, integrating [2, 3]\n└ @ PhyloGaussianBeliefProp ...\n┌ Error: belief H6I10I15, integrating [2, 3]\n└ @ PhyloGaussianBeliefProp ...","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"However, with regularization, there are no ill-defined messages for a single iteration of calibration:","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"julia> PGBP.init_beliefs_assignfactors!(b, m, tbl_x, df.taxon, net.nodes_changed); # reset to initial beliefs\n\njulia> PGBP.regularizebeliefs_bynodesubtree!(fgb, fg); # regularize by node subtree\n\njulia> PGBP.calibrate!(fgb, sched); # no ill-defined messages\n\njulia> PGBP.init_beliefs_assignfactors!(b, m, tbl_x, df.taxon, net.nodes_changed); # reset to initial beliefs\n\njulia> PGBP.regularizebeliefs_onschedule!(fgb, fg); # regularize by on schedule\n\njulia> PGBP.calibrate!(fgb, sched); # no ill-defined messages","category":"page"},{"location":"man/regularization/","page":"Regularization","title":"Regularization","text":"Note that this does not necessarily guarantee that subsequent iterations avoid ill-defined messages.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"CurrentModule = PhyloGaussianBeliefProp","category":"page"},{"location":"man/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"This version of the package is a proof of concept, and not all methods have been fully implemented.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"A minimal API is still incomplete, and so we demonstrate the package's various capabilities as pipelines involving multiple internal functions. A complete API that wraps these pipelines will be made available later.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"In what follows, we use simulated trait data. In most of this manual, we use as an example the network topology from Lazaridis et al. (2014), Figure 3 [1], displayed below, with branch lengths arbitrarily set to 1 and inheritance probabilities (admixture proportions) set arbibitrarily to 0.4 and 0.6 at each hybrid node.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"man/getting_started/#Exact-likelihood-for-fixed-parameters","page":"Getting started","title":"Exact likelihood for fixed parameters","text":"","category":"section"},{"location":"man/getting_started/#1.-Read-in-the-network-and-the-tip-data","page":"Getting started","title":"1. Read in the network and the tip data","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> using PhyloGaussianBeliefProp\n\njulia> const PGBP = PhyloGaussianBeliefProp;\n\njulia> using PhyloNetworks # `readTopology`, `tipLabels`, `preorder!`\n\njulia> using DataFrames # `DataFrame`\n\njulia> net = readTopology(pkgdir(PGBP, \"test/example_networks\", \"lazaridis_2014.phy\"))\nPhyloNetworks.HybridNetwork, Rooted Network\n23 edges\n20 nodes: 7 tips, 4 hybrid nodes, 9 internal tree nodes.\ntip labels: Mbuti, Onge, Karitiana, MA1, ...\n(Mbuti:1.0,(((Onge:1.0,#H1:0.01::0.4)EasternNorthAfrican:1.0,(((Karitiana:1.0)#H1:0.01::0.6,(MA1:1.0,#H3:0.01::0.4)ANE:1.0)AncientNorthEurasian:1.0,(((#H2:0.01::0.4)#H3:0.01::0.6,Loschbour:1.0)WHG:1.0,#H4:0.01::0.4)WestEurasian:1.0)I1:1.0)I2:1.0,((European:1.0)#H2:0.01::0.6,Stuttgart:1.0)#H4:0.01::0.6)NonAfrican:1.0)I3;\njulia> preorder!(net) # updates net.nodes_changed to contain network nodes listed in preorder\n\njulia> df = DataFrame(taxon=tipLabels(net), # simulated using `simulate(net, ParamsBM(0, 1))` from PhyloNetworks\n               x=[1.343, 0.841, -0.623, -1.483, 0.456, -0.081, 1.311])\n7×2 DataFrame\n Row │ taxon      x       \n     │ String     Float64 \n─────┼────────────────────\n   1 │ Mbuti        1.343\n   2 │ Onge         0.841\n   3 │ Karitiana   -0.623\n   4 │ MA1         -1.483\n   5 │ Loschbour    0.456\n   6 │ European    -0.081\n   7 │ Stuttgart    1.311","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"In this example, the trait x is univariate. We have mapped the observed data to the corresponding species in the dataframe df.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The call to preorder! updates net to contain a list of its nodes arranged in preorder (or topological ordering). Many internals in the package assume that this information is available, and so it is important that this be called immediately after reading in the network!","category":"page"},{"location":"man/getting_started/#2.-Choose-an-evolutionary-model","page":"Getting started","title":"2. Choose an evolutionary model","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"At the moment, models available are: UnivariateBrownianMotion, UnivariateOrnsteinUhlenbeck, MvDiagBrownianMotion, MvFullBrownianMotion.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Note however that not all methods may be implemented across all models. See section Evolutionary models for more details on the available models.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> m = PGBP.UnivariateBrownianMotion(1, 0) # σ2 = 1.0, μ = 0.0\nUnivariate Brownian motion\n\n- evolutionary variance rate σ2 :\n1.0\n- root mean μ :\n0.0","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"We specify a univariate Brownian motion with mean mu=0 and variance rate sigma^2=1. We want to compute the likelihood for these particular values, though other values may better fit the data.","category":"page"},{"location":"man/getting_started/#3.-Build-a-cluster-graph-from-the-network","page":"Getting started","title":"3. Build a cluster graph from the network","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Methods available are: Bethe, LTRIP, JoinGraphStructuring, Cliquetree.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"We first choose Cliquetree to compute the likelihood exactly. Other methods may return a loopy cluster graph, which gives an approximate likelihood. See section Cluster graphs for more background on cluster graphs.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> ct = PGBP.clustergraph!(net, PGBP.Cliquetree())\nMeta graph based on a Graphs.SimpleGraphs.SimpleGraph{Int8} with vertex labels of type Symbol, vertex metadata of type Tuple{Vector{Symbol}, Vector{Int8}}, edge metadata of type Vector{Int8}, graph metadata given by :cliquetree, and default weight 0\n\njulia> PGBP.labels(ct) |> collect # cluster labels\n17-element Vector{Symbol}:\n :H1EasternNorthAfricanAncientNorthEurasian\n :EasternNorthAfricanAncientNorthEurasianI2\n :OngeEasternNorthAfrican\n :StuttgartH4\n :MbutiI3\n :H2H3H4\n :H3ANEWHGH4\n :ANEWHGH4WestEurasian\n :LoschbourWHG\n :KaritianaH1\n :EuropeanH2\n :AncientNorthEurasianWestEurasianI1NonAfrican\n :ANEH4WestEurasianNonAfrican\n :ANEAncientNorthEurasianWestEurasianNonAfrican\n :AncientNorthEurasianI1I2NonAfrican\n :NonAfricanI3\n :MA1ANE","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"See that each cluster's label is derived by concatenating the labels of the nodes it contains.","category":"page"},{"location":"man/getting_started/#4.-Initialize-cluster-graph-beliefs","page":"Getting started","title":"4. Initialize cluster graph beliefs","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"ct describes the topology of our cluster graph, but does not track the beliefs for each cluster. Next, we:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"allocate memory for these beliefs\ninitialize their values using the evolutionary model\nwrap them within another data structure to facilitate message passing.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> using Tables # `columntable`\n\njulia> tbl_x = columntable(select(df, :x)) # extract trait `x` from `df` as a column table\n(x = [1.343, 0.841, -0.623, -1.483, 0.456, -0.081, 1.311],)\n\njulia> b = PGBP.init_beliefs_allocate(tbl_x, df.taxon, net, ct, m); # allocate memory for beliefs\n\njulia> length(b) # no. of beliefs\n33\n\njulia> b[1] # belief for cluster {H1, EasternNorthAfrican, AncientNorthEurasian} before factor assignment\nbelief for Cluster H1EasternNorthAfricanAncientNorthEurasian, 1 traits × 3 nodes, dimension 3.\nNode labels: Int8[17, 16, 10]\ntrait × node matrix of non-degenerate beliefs:\nBool[1 1 1]\nexponential quadratic belief, parametrized by\nμ: [0.0, 0.0, 0.0]\nh: [0.0, 0.0, 0.0]\nJ: [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0]\ng: 0.0\n\njulia> PGBP.init_beliefs_assignfactors!(b, m, tbl_x, df.taxon, net.nodes_changed); # initialize beliefs from evolutionary model\n\njulia> b[1] # belief for cluster {H1, EasternNorthAfrican, AncientNorthEurasian} after factor assignment\nbelief for Cluster H1EasternNorthAfricanAncientNorthEurasian, 1 traits × 3 nodes, dimension 3.\nNode labels: Int8[17, 16, 10]\ntrait × node matrix of non-degenerate beliefs:\nBool[1 1 1]\nexponential quadratic belief, parametrized by\nμ: [0.0, 0.0, 0.0]\nh: [0.0, 0.0, 0.0]\nJ: [192.30769230769232 -76.92307692307693 -115.38461538461539; -76.92307692307693 30.769230769230774 46.15384615384616; -115.38461538461539 46.15384615384616 69.23076923076923]\ng: 1.7106097934927051\n\njulia> ctb = PGBP.ClusterGraphBelief(b); # wrap beliefs to facilitate message passing\n\njulia> PGBP.nclusters(ctb) # no. of cluster beliefs\n17\n\njulia> PGBP.nsepsets(ctb) # no. of edge/sepset beliefs\n16","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"b is a vector of all beliefs, one for each cluster and edge (also known as sepset) in the cluster graph. The edge beliefs store the most recent messages passed between neighboring clusters.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Recall that each cluster or edge is associated with a set of nodes. The scope x of its belief comes from stacking the trait vectors for these nodes. A belief with scope x is parametrized by (bmJhg) as follows:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"exp(-x^topbmJx2 + h^topx + g)","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"We show belief b[1] before and after factor (i.e. conditional distribution) assignment. Note that its J and g parameters are changed.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"ctb contains b with added information to locate specific beliefs in b from their corresponding cluster/edge labels in ct, and added storage to log information during message passing.","category":"page"},{"location":"man/getting_started/#5.-Propose-a-schedule-from-the-cluster-graph","page":"Getting started","title":"5. Propose a schedule from the cluster graph","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"A message schedule can be described by a sequence of cluster pairs. Each pairing tells us to send a message between these clusters (which must be neighbors), while the order within the pair indicates the sender and the recipient.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"We build a message schedule sched from ct by finding a minimal set of spanning trees for the cluster graph that together cover all its edges (i.e. neighbor cluster pairs). Each spanning tree is represented as a sequence of edges following some preorder traversal of ct. See section Message schedules for more details on message schedules.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Since ct is a clique tree, there is a single spanning tree (sched[1]). We extract and display the preorder sequence of edges from sched[1]. In this example, NonAfricanI3 is the root cluster of ct, and KaritianaH1 is a leaf cluster.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> sched = PGBP.spanningtrees_clusterlist(ct, net.nodes_changed);\n\njulia> DataFrame(parent=sched[1][1], child=sched[1][2]) # edges of tree 1 in preorder\n16×2 DataFrame\n Row │ parent                             child                             \n     │ Symbol                             Symbol                            \n─────┼──────────────────────────────────────────────────────────────────────\n   1 │ NonAfricanI3                       AncientNorthEurasianWestEurasian…\n   2 │ AncientNorthEurasianWestEurasian…  ANEAncientNorthEurasianWestEuras…\n   3 │ ANEAncientNorthEurasianWestEuras…  ANEH4WestEurasianNonAfrican\n   4 │ ANEH4WestEurasianNonAfrican        ANEWHGH4WestEurasian\n   5 │ ANEWHGH4WestEurasian               H3ANEWHGH4\n   6 │ H3ANEWHGH4                         LoschbourWHG\n   7 │ H3ANEWHGH4                         MA1ANE\n   8 │ NonAfricanI3                       MbutiI3\n   9 │ H3ANEWHGH4                         H2H3H4\n  10 │ H2H3H4                             EuropeanH2\n  11 │ H2H3H4                             StuttgartH4\n  12 │ AncientNorthEurasianWestEurasian…  AncientNorthEurasianI1I2NonAfric…\n  13 │ AncientNorthEurasianI1I2NonAfric…  EasternNorthAfricanAncientNorthE…\n  14 │ EasternNorthAfricanAncientNorthE…  H1EasternNorthAfricanAncientNort…\n  15 │ H1EasternNorthAfricanAncientNort…  OngeEasternNorthAfrican\n  16 │ H1EasternNorthAfricanAncientNort…  KaritianaH1","category":"page"},{"location":"man/getting_started/#6.-Calibrate-beliefs-with-the-schedule","page":"Getting started","title":"6. Calibrate beliefs with the schedule","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"We apply one iteration of belief propagation on ctb following the schedule sched. Since ct is a clique tree, the resulting beliefs are guaranteed to be calibrated (i.e. the beliefs of neighbor clusters agree marginally over the sepset between them).","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> PGBP.calibrate!(ctb, sched);","category":"page"},{"location":"man/getting_started/#7.-Extract-the-log-likelihood","page":"Getting started","title":"7. Extract the log-likelihood","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"On a calibrated clique tree, there are two ways to obtain the log-likelihood:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"integrate any belief over its scope to get its normalization constant (norm)\ncompute the factored_energy, which approximates the log-likelihood on loopy cluster graphs but is exact on a clique tree","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> (_, norm) = PGBP.integratebelief!(b[1]); # `norm` is the integral of `b[1]` over its scope\n\njulia> norm\n-11.273958980921249\n\njulia> (_, _, fe) = PGBP.factored_energy(ctb); # `fe` is the factored energy from the cluster/edge beliefs\n\njulia> fe\n-11.273958980921272","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The first approach is more efficient (it uses only one belief, rather than all beliefs), but only works for a clique tree. The normalization constant of a belief from a calibrated loopy cluster graph cannot be similarly interpreted.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"We see that both approaches return the same value, modulo rounding error.","category":"page"},{"location":"man/getting_started/#Exact-inference","page":"Getting started","title":"Exact inference","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"In the section above, we computed the log-likelihood for mu=0, sigma^2=1.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Now we find mu=widehatmu and sigma^2=widehatsigma^2 that maximize the log-likelihood. There are two options:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"iterative optimization\nexact computation using belief propagation","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> mod, ll, _ = PGBP.calibrate_optimize_cliquetree!( # iterative optimization\n               ctb, # beliefs\n               ct, # clique tree\n               net.nodes_changed, # network nodes in preorder\n               tbl_x, # trait data\n               df.taxon, # tip labels\n               PGBP.UnivariateBrownianMotion, # type of evolutionary model\n               (1.0, 0)); # starting parameters: σ2 = 1.0, μ = 0.0\n\njulia> mod # ML estimates\nUnivariate Brownian motion\n\n- evolutionary variance rate σ2 :\n0.31812948857664464\n- root mean μ :\n1.1525789703803826\n\njulia> ll # log-likelihood for ML estimates\n-8.656529929205773\n\njulia> mod, _ = PGBP.calibrate_exact_cliquetree!( # exact computation\n               ctb,\n               sched[1], # schedule the order in which edges (sepsets) are traversed\n               net.nodes_changed,\n               tbl_x,\n               df.taxon,\n               PGBP.UnivariateBrownianMotion);\n\njulia> mod # REML estimate for σ2, ML estimate for μ\nUnivariate Brownian motion\n\n- evolutionary variance rate σ2 :\n0.37115107002903314\n- root mean μ :\n1.1525789703844822","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Both options return the maximum-likelihood (ML) estimate for mu, though the latter returns the restricted maximum-likelihood (REML) estimate for sigma^2.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Strictly speaking, the estimates from the latter option do not jointly maximize the log-likelihood. However, the REML estimate for sigma^2 is generally less biased than its ML counterpart. In this simple model, the REML estimate is just equal to the ML estimate up to a factor (n-1)n, with n the number of tips in the network:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> PGBP.varianceparam(mod) * (net.numTaxa - 1) / net.numTaxa # sigma2_REML = (n-1)/n * sigma2_ML\n0.3181294885963141","category":"page"},{"location":"man/getting_started/#Approximate-inference","page":"Getting started","title":"Approximate inference","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Suppose now that we use a loopy cluster graph instead of a clique tree. We choose Bethe to construct a Bethe cluster graph (also known as factor graph) fg.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"As before, we set up a data structure fgb to track the beliefs of the factor graph during message passing. Then we call calibrate_optimize_clustergraph!, the analog of calibrate_optimize_cliquetree! from earlier:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> fg = PGBP.clustergraph!(net, PGBP.Bethe()) # factor graph\nMeta graph based on a Graphs.SimpleGraphs.SimpleGraph{Int8} with vertex labels of type Symbol, vertex metadata of type Tuple{Vector{Symbol}, Vector{Int8}}, edge metadata of type Vector{Int8}, graph metadata given by :Bethe, and default weight 0\n\njulia> b_fg = PGBP.init_beliefs_allocate(tbl_x, df.taxon, net, fg, m); # allocate memory for beliefs\n\njulia> fgb = PGBP.ClusterGraphBelief(b_fg); # wrap beliefs to facilitate message passing\n\njulia> mod, fe, _ = PGBP.calibrate_optimize_clustergraph!(fgb, fg, net.nodes_changed, tbl_x,\n               df.taxon, PGBP.UnivariateBrownianMotion, (1.0, 0));\n\njulia> mod # parameter estimates\nUnivariate Brownian motion\n\n- evolutionary variance rate σ2 :\n0.3181295330492941\n- root mean μ :\n1.1525789120595669\n\njulia> fe # factored energy approximation to the log-likelihood\n-8.587925093657454","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"We see that both parameter estimates are very close to their maximum-likelihood counterparts (within 10⁻⁴ percent), and the factored energy slightly overestimates the log-likelihood for these values (within 1 percent).","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"CurrentModule = PhyloGaussianBeliefProp","category":"page"},{"location":"man/clustergraphs/#Cluster-graphs","page":"Cluster graphs","title":"Cluster graphs","text":"","category":"section"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"A cluster graph groups the nodes X_1dotsX_m of the phylogeny into several (possibly intersecting) clusters/subsets, such that for any node:","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"there is ge 1 cluster that contains it and its parents (i.e. the clusters are (node) family-preserving)\nthe clusters that contain it are always joined as a tree, whose edge labels contain that node","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"Each edge between two clusters mathcalC_imathcalC_j is labeled with a node subset mathcalS_ijsubseteqmathcalC_icapmathcalC_j based on the second property. These labels are referred to as sepsets (i.e a \"sep(arating) sets\"). ","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"Intuitively, if the factors of a joint distribution p_theta over the nodes are distributed among the clusters, then the topology of the cluster graph implies the possible computational pathways in which these factors may be sequentially \"combined\" by product or marginalization.","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"For example, a cluster's belief is the cumulative result of computations that might follow some walk along the cluster graph, ending at that cluster. This is then interpreted as an estimate of its conditional distribution given the data.","category":"page"},{"location":"man/clustergraphs/#Clique-tree","page":"Cluster graphs","title":"Clique tree","text":"","category":"section"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"A cluster graph whose topology is a tree is known as a clique tree. We provide the option to construct a clique tree, and 3 further options (below) for constructing (potentially) loopy cluster graphs.","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"A clique tree tends to have more clusters of larger size than a loopy cluster graph. The time-complexity of message passing on a cluster graph is parametrized by maximum cluster size, and so clique trees allow for exact inference but at a greater cost than approximate inference on a loopy cluster graph. Below is an example using a virus recombination network from Müller et al. (2022, Fig 1a) [4], with inheritance probabilities estimated from the inferred recombination breakpoints (see muller2022_nexus2newick.jl).","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"julia> net = readTopology(pkgdir(PhyloGaussianBeliefProp, \"test/example_networks\", \"muller_2022.phy\")); # 1161 edges, 801 nodes: 40 tips, 361 hybrid nodes, 400 internal tree nodes.\n\njulia> preorder!(net)\n\njulia> ct = PGBP.clustergraph!(net, PGBP.Cliquetree());\n\njulia> PGBP.labels(ct) |> length # no. of vertices/clusters in clique tree\n664\n\njulia> PGBP.edge_labels(ct) |> length # no. of edges in clique tree, one less than no. of clusters\n663\n\njulia> clusters = PGBP.labels(ct) |> collect; # vector of cluster labels\n\njulia> clusters[1] # cluster label is the concatenation of node labels\n:I300I301I302I189\n\njulia> ct[clusters[1]] # access metadata for `cluster[1]`: (node labels, preorder indices), nodes are arranged by decreasing preorder index\n([:I300, :I301, :I302, :I189], Int16[722, 719, 717, 487])\n\njulia> using StatsBase # `summarystats`\n\njulia> (length(ct[cl][1]) for cl in PGBP.labels(ct)) |> collect |> summarystats # distribution of cluster sizes\nSummary Stats:\nLength:         664\nMissing Count:  0\nMean:           6.728916\nStd. Deviation: 6.120608\nMinimum:        2.000000\n1st Quartile:   4.000000\nMedian:         5.000000\n3rd Quartile:   7.000000\nMaximum:        54.000000","category":"page"},{"location":"man/clustergraphs/#Bethe-/-Factor-graph","page":"Cluster graphs","title":"Bethe / Factor graph","text":"","category":"section"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"The Bethe cluster graph has a cluster for each node family (factor clusters) and for each node (variable clusters). Each factor cluster is joined to the variable cluster for any node it contains.","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"julia> fg = PGBP.clustergraph!(net, PGBP.Bethe());\n\njulia> (PGBP.labels(fg) |> length, PGBP.edge_labels(fg) |> length) # (no. of clusters, no. of edges)\n(1557, 1914)\n\njulia> (length(fg[cl][1]) for cl in PGBP.labels(fg)) |> collect |> summarystats\nSummary Stats:\nLength:         1557\nMissing Count:  0\nMean:           1.743738\nStd. Deviation: 0.809151\nMinimum:        1.000000\n1st Quartile:   1.000000\nMedian:         2.000000\n3rd Quartile:   2.000000\nMaximum:        3.000000","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"If each hybrid node has 2 parents (as for net), then the maximum cluster size is 3.","category":"page"},{"location":"man/clustergraphs/#Join-graph-structuring","page":"Cluster graphs","title":"Join-graph structuring","text":"","category":"section"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"Join-graph structuring allows the user to specify the maximum cluster size k^*. See JoinGraphStructuring for more details on the algorithm.","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"julia> jg = PGBP.clustergraph!(net, PGBP.JoinGraphStructuring(10));\n\njulia> (PGBP.labels(jg) |> length, PGBP.edge_labels(jg) |> length)\n(1001, 1200)\n\njulia> (length(jg[cl][1]) for cl in PGBP.labels(jg)) |> collect |> summarystats\nSummary Stats:\nLength:         1001\nMissing Count:  0\nMean:           6.036963\nStd. Deviation: 2.177070\nMinimum:        1.000000\n1st Quartile:   4.000000\nMedian:         6.000000\n3rd Quartile:   8.000000\nMaximum:        10.000000","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"Since the set of clusters has to be family-preserving (see above), k^* cannot be smaller than the largest node family (i.e. a node and its parents). For example, if the network has hybrid nodes, then k^*ge 3 necessarily.","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"julia> jg = PGBP.clustergraph!(net, PGBP.JoinGraphStructuring(2));\nERROR: maxclustersize 2 is smaller than the size of largest node family 3.","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"On the other extreme, suppose we set k^*=54, the maximum cluster size of the clique tree above:","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"julia> jg2 = PGBP.clustergraph!(net, PGBP.JoinGraphStructuring(54));\n\njulia> (PGBP.labels(jg2) |> length, PGBP.edge_labels(jg2) |> length)\n(801, 800)\n\njulia> (length(jg2[cl][1]) for cl in PGBP.labels(jg2)) |> collect |> summarystats\nSummary Stats:\nLength:         801\nMissing Count:  0\nMean:           9.539326\nStd. Deviation: 9.953078\nMinimum:        1.000000\n1st Quartile:   4.000000\nMedian:         5.000000\n3rd Quartile:   10.000000\nMaximum:        54.000000","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"then it turns out the jg2 is a clique tree (since the number of clusters and edges differ by 1), though not the same one as ct. Generally, a cluster graph with larger clusters is less likely to be loopy than one with smaller clusters.","category":"page"},{"location":"man/clustergraphs/#LTRIP","page":"Cluster graphs","title":"LTRIP","text":"","category":"section"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"For LTRIP, the user provides the set of clusters, which are assumed to be family-preserving (see above).","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"For each node, the clusters that contain it are joined as a tree, prioritizing edges formed with clusters that intersect heavily with others. See LTRIP for details.\nThe trees for each node are layered on one another (the sepsets for an edge are merged) to produce the cluster graph.","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"As an example, we use the clusters from join-graph structuring:","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"julia> clusters = (jg[cl][2] for cl in PGBP.labels(jg)) |> collect; # vector of clusters, each given as a vector of preorder indices in decreasing order\n\njulia> lg = PGBP.clustergraph!(net, PGBP.LTRIP(clusters, net));\n\njulia> (PGBP.labels(lg) |> length, PGBP.edge_labels(lg) |> length)\n(1001, 1249)","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"The summary statistics would be the same as for jg's clusters, though it appears that lg is more densely connected than jg.","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"If the user does not provide the clusters, then the set of node families (see nodefamilies) is used by default:","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"julia> lg = PGBP.clustergraph!(net, PGBP.LTRIP(net));\n\njulia> (PGBP.labels(lg) |> length, PGBP.edge_labels(lg) |> length)\n(801, 1158)","category":"page"},{"location":"man/clustergraphs/","page":"Cluster graphs","title":"Cluster graphs","text":"There are 801 clusters, 1 per node (family), as expected.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PhyloGaussianBeliefProp","category":"page"},{"location":"#PhyloGaussianBeliefProp","page":"Home","title":"PhyloGaussianBeliefProp","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PhyloGaussianBeliefProp is a Julia package for the analysis of Gaussian models on phylogenetic networks using belief propagation (aka message passing).","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/installation.md\",\n    \"man/getting_started.md\",\n    \"man/background.md\",\n    \"man/evolutionary_models.md\",\n    \"man/clustergraphs.md\",\n    \"man/regularization.md\",\n    \"man/message_schedules.md\"\n]\nDepth = 3","category":"page"},{"location":"#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [PhyloGaussianBeliefProp]","category":"page"},{"location":"#PhyloGaussianBeliefProp.AbstractClusterGraphMethod","page":"Home","title":"PhyloGaussianBeliefProp.AbstractClusterGraphMethod","text":"AbstractClusterGraphMethod\n\nAbstract type for cluster graph construction algorithms.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.BPPosDefException","page":"Home","title":"PhyloGaussianBeliefProp.BPPosDefException","text":"BPPosDefException\n\nException thrown when a belief message cannot be computed, that is, when the submatrix of the precision J, subsetted to the variables to be integrated out, is not positive definite. It has a message msg field (string), and an info field (integer) inherited from LinearAlgebra.PosDefException, to indicate the location of (one of) the eigenvalue(s) which is (are) less than/equal to 0.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.Belief","page":"Home","title":"PhyloGaussianBeliefProp.Belief","text":"Belief{T<:Real,Vlabel<:AbstractVector,P<:AbstractMatrix{T},V<:AbstractVector{T},M} <: AbstractBelief{T}\n\nA \"belief\" is an exponential quadratic form, using the canonical parametrization:\n\nC(x | J,h,g) = exp( -(1/2)x'Jx + h'x + g )\n\nIt is a normalized distribution density if\n\ng = - (1/2) (log(2πΣ) + μ'Jμ)\n  = - entropy of normalized distribution + (1/2) dim(μ) - (1/2) μ'Jμ.\n\nμ is the mean, of type V (stored but typically not updated)\nh = inv(Σ)μ is the potential, also of type V,\nΣ is the variance matrix (not stored)\nJ = inv(Σ) is the precision matrix, of type P\ng is a scalar to get the unnormalized belief: of type MVector{1,T} to be mutable.\n\nSee MvNormalCanon{T,P,V} in Distributions.jl\n\nOther fields are used to track which cluster or edge the belief corresponds to, and which traits of which variables are in scope:\n\nnodelabel of type Vlabel\nntraits\ninscope\ntype: cluster or sepset\nmetadata of type M: Symbol for clusters, Tuple{Symbol,Symbol} for sepsets.\n\nMethods for a belief b:\n\nnodelabels(b): vector of node labels, of type Vlabel, e.g. Int8 if nodes are labelled by their preorder index in the original phylogeny\nntraits(b): number of traits (dimension of the random variable x above)\ninscope(b): matrix of booleans (trait i in row i and and node j in column j)\nnodedimensions(b): vector of integers, with jth value giving the dimension (number of traits in scope) of node j.\ndimension(b): total dimension of the belief, that is, total number of traits in scope. Without any missing data, that would be ntraits × length of nodelabels.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.Belief-Union{Tuple{Tlabel}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any}, Tuple{AbstractVector{Tlabel}, Integer, BitArray, Any, Any, Type}} where Tlabel<:Integer","page":"Home","title":"PhyloGaussianBeliefProp.Belief","text":"Belief(nodelabels, numtraits, inscope, belieftype, metadata, T=Float64)\n\nConstructor to allocate memory for one cluster, and initialize objects with 0s to initialize the belief with the constant function exp(0)=1.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.Bethe","page":"Home","title":"PhyloGaussianBeliefProp.Bethe","text":"Bethe\n\nSubtype of AbstractClusterGraphMethod.\n\nAlgorithm\n\nA Bethe cluster graph (also known as factor graph) has:\n\na factor-cluster {v, parents(v}} for each node-family in the network, that is, for each non-root node v (a family is a child node and all of its parents)\nwith one exception: if v's family is included in another family, then no factor-cluster is created for v.\na variable-cluster {v} for each non-leaf node v in the network, or more specifically, for each node v that belongs in more than 1 factor.\n\nEach variable-cluster {v} is joined to the factor-clusters that contain v, by an edge labelled with sepset {v}.\n\nReferences\n\nD. Koller and N. Friedman. Probabilistic graphical models: principles and techniques. MIT Press, 2009. ISBN 9780262013192.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.Cliquetree","page":"Home","title":"PhyloGaussianBeliefProp.Cliquetree","text":"Cliquetree\n\nSubtype of AbstractClusterGraphMethod.\n\nAlgorithm\n\nmoralize the network (connect partners that share a child).\ntriangulate the resulting undirected graph using greedy min-fill, see triangulate_minfill!(graph).\nextract the maximal cliques of the resulting chordal graph.\ncalculate the edge weight between each pair of maximal cliques as the size of their intersection\nfind a maximum-weight spanning tree\nlabel the retained edges (in the spanning tree) by the intersection of the two cliques they connect.\n\nReferences\n\nD. Koller and N. Friedman. Probabilistic graphical models: principles and techniques. MIT Press, 2009. ISBN 9780262013192.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.ClusterGraphBelief","page":"Home","title":"PhyloGaussianBeliefProp.ClusterGraphBelief","text":"ClusterGraphBelief{B<:Belief, F<:FamilyFactor, M<:MessageResidual}\n\nStructure to hold a vector of beliefs, with cluster beliefs coming first and sepset beliefs coming last. Fields:\n\nbelief: vector of beliefs\nfactor: vector of initial cluster beliefs after factor assignment\nnclusters: number of clusters\ncdict: dictionary to get the index of a cluster belief from its node labels\nsdict: dictionary to get the index of a sepset belief from the labels of  its two incident clusters\nmessageresidual: dictionary to log information about sepset messages, which can be used to track calibration or help adaptive scheduling with residual BP. See MessageResidual. The keys of messageresidual are tuples of cluster labels, similar to a sepset's metadata. Each edge in the cluster graph has 2 messages corresponding to the 2 directions in which a message can be passed, with keys: (label1, label2) and (label2, label1). The cluster receiving the message is the first label in the tuple, and the sending cluster is the second.\n\nAssumptions:\n\nFor a cluster belief, the cluster's nodes are stored in the belief's metadata.\nFor a sepset belief, its incident clusters' nodes are in the belief's metadata.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.ClusterGraphBelief-Union{Tuple{Vector{B}}, Tuple{B}} where B<:PhyloGaussianBeliefProp.Belief","page":"Home","title":"PhyloGaussianBeliefProp.ClusterGraphBelief","text":"ClusterGraphBelief(belief_vector::Vector{B})\n\nConstructor of a ClusterGraphBelief with belief belief_vector and all other fields constructed accordingly. New memory is allocated for these other fields, e.g. for factors (with data copied from cluster beliefs) and message residuals (with data initialized to 0 but of size matching that from sepset beliefs)\n\nTo construct the input vector of beliefs, see init_beliefs_allocate and init_beliefs_assignfactors!\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.EvolutionaryModel","page":"Home","title":"PhyloGaussianBeliefProp.EvolutionaryModel","text":"EvolutionaryModel{T}\n\nEvolutionary model type, with T the element type in all parameter vector and matrices. Implemented models include the UnivariateBrownianMotion.\n\nAn object of this type must contain at least the following elements:\n\nμ: the mean of the trait at the root.\nv: the variance of the trait at the root. Can be zero (fixed root) or infinite.\n\nNew evolutionary models must implement the following interfaces:\n\nparams(obj::EvolutionaryModel)\nparams_optimize(obj::EvolutionaryModel)\nparams_original(obj::EvolutionaryModel, transformedparams::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.FamilyFactor-Union{Tuple{PhyloGaussianBeliefProp.AbstractBelief{T}}, Tuple{T}} where T","page":"Home","title":"PhyloGaussianBeliefProp.FamilyFactor","text":"FamilyFactor(belief::AbstractBelief{T}) where T\n\nConstructor to allocate memory for one family factor, with canonical parameters and metadata initialized to be a copy of those in belief. FamilyFactors metadata are supposed to be symbols, so this constructor should fail if its input is a sepset belief, whose metadata is a Tuple of Symbols.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.HeterogeneousBrownianMotion","page":"Home","title":"PhyloGaussianBeliefProp.HeterogeneousBrownianMotion","text":"HeterogeneousBrownianMotion{T,U,V,W} <: HeterogeneousBM{T}\n\nType for a heterogeneous Brownian motion model, univariate or multivariate. Along each edge, evolution follows a Brownian motion. Each edge can have its own variance rate. This model has no shifts, and no extra hybrid variance. By default, the root is fixed with prior variance 0.\n\nT is the scalar type, U is the type for the root mean (vector of length d, where d is the trait dimension, even if univariate), V is a matrix type for the root variance, and W the matrix type of each variance rate, one per color. For a univariate BM, we may have W=T and V=Vector{T}. For a multivariate BM, we may have W=V<:Matrix{T}. This is such that each field is mutable, so we can update model parameters in place within the model object, itself immutable.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.HeterogeneousShiftedBrownianMotion","page":"Home","title":"PhyloGaussianBeliefProp.HeterogeneousShiftedBrownianMotion","text":"HeterogeneousShiftedBrownianMotion{T,U,V,W} <: HeterogeneousBM{T}\n\nType for a heterogeneous Brownian motion model like HeterogeneousBrownianMotion but with a possible shift in the mean along each edge.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.JoinGraphStructuring","page":"Home","title":"PhyloGaussianBeliefProp.JoinGraphStructuring","text":"JoinGraphStructuring\n\nSubtype of AbstractClusterGraphMethod.\n\nFieldnames\n\nmaxclustersize: upper limit for cluster size. This value must be at least the size of the largest node family in the input phylogenetic network, normally 3 if the network is bicombining (each hybrid node has 2 parents, never more). See nodefamilies(net).\n\nConstructors\n\nJoinGraphStructuring(maxclustersize, net):  checks that the input maxclustersize is valid for net\n\nAlgorithm, by Mateescu et al. (2010)\n\nRequires:\n\na user-specified maximum cluster size\nan elimination order for the nodes in the HybridNetwork, hopefully yielding a small induced-width, e.g. from a heuristic such as greedy min-fill (see triangulate_minfill!(graph)).\n\nEach node in net labels a \"bucket\", and these buckets are ordered according to the elimination order, e.g. the highest-priority bucket is labelled by the first node in the elimination order.\nNode families are assigned to buckets based on the highest-priority node they contain. For example, if {1,4,9} forms a node family and if node 4 is higher in the elimination order than nodes 1 or 9, then {1,4,9} gets assigned to bucket 4.\nNode families are clusters (of nodes), and we refer to the clusters within a bucket as \"minibuckets\". Minibuckets within a bucket can be merged as long as the size of their union does not exceed the maximum cluster size allowed. Sometimes, this can be done in multiple ways.\nStarting with the highest-priority bucket, we create new minibuckets by \"marginalizing out\" the bucket label from each existing minibucket (these are left unchanged in the process).\nEach new minibucket is joined to its \"originator\" minibucket by an edge that is labeled by their intersection (i.e. the variables in the new minibucket). Each new minibucket is then reassigned to a new (and necessarily lower-priority) bucket based on its highest priority node. Merging can take place during reassignment as long as the the maximum cluster size is respected. The union of 2 minibuckets retains the edges of each of minibucket.\nSteps 4 & 5 are carried out for each bucket in order of priority.\nThe resulting minibuckets in each bucket are then joined in a chain (there is some degree of freedom for how this can be done), where each edge is labelled by the bucket label.\n\nReferences\n\nR. Mateescu, K. Kask, V.Gogate, and R. Dechter. Join-graph propagation algorithms. Journal of Artificial Intelligence Research, 37:279-328, 2010 doi: 10.1613/jair.2842.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.LTRIP","page":"Home","title":"PhyloGaussianBeliefProp.LTRIP","text":"LTRIP{T<:Integer}\n\nSubtype of AbstractClusterGraphMethod. A HybridNetwork and a valid LTRIP are passed to clustergraph! to construct a cluster graph from the user-provided clusters based on the Layered Trees Running Intersection Property algorithm of Streicher & du Preez (2017).\n\nFieldnames\n\nclusters: vector of clusters, required to be family-preserving with respect to some HybridNetwork – see isfamilypreserving. Within each cluster, nodes (identified by their preorder index in the network) are required to be sorted in decreasing order (for postorder)\n\nConstructors\n\nLTRIP(net): uses nodefamilies(net) as input clusters, which are guaranteed to be family-preserving\nLTRIP(clusters, net): checks if that clusters provided are family-preserving,  then sorts each cluster in decreasing order (modifying them in place!)  before creating the LTRIP object.\n\nThey assume, with no check, that net already has a preordering.\n\nAlgorithm\n\nAn initial graph G is considered, in which each input cluster is a node. An edge (C1,C2) is added if clusters C1 and C2 share at least 1 node (in net). The weight of edge (C1,C2) is defined as the size of the intersection C1 ∩ C2.\nFor each node n in net, the subgraph of G induced by the clusters containing n, G_n, has its weights adjusted as follows:\nthe edges of maximum weight (within G_n) are identified, then\nthe weight of each edge is increased by the number of max-weight edges that either of its endpoints adjacent to.\nThen, LTRIP finds a maximum-weight spanning tree of G_n. The edges of this tree are all labelled with {n} (or its label or preorder index).\nThe spanning trees for each node are layered on one another to form a cluster graph. In other words, an edge (C1,C2) is added if it is present is any spanning tree. If so, its sepset is the union of its labels across the different spanning trees.\n\nReferences\n\nS. Streicher and J. du Preez. Graph Coloring: Comparing Cluster Graphs to Factor Graphs. In Proceedings of the ACM Multimedia 2017 Workshop on South African Academic Participation, pages 35-42, 2017. doi: 10.1145/3132711.3132717.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.MessageResidual","page":"Home","title":"PhyloGaussianBeliefProp.MessageResidual","text":"MessageResidual{T<:Real, P<:AbstractMatrix{T}, V<:AbstractVector{T}} <: AbstractResidual{T}\n\nStructure to store the most recent computation history of a message, in the form of the ratio: sent_message / current_sepset_belief, when a message is sent from one cluster to another along a given sepset. At calibration, this ratio is 1. For Gaussian beliefs, this ratio is an exponential quadratic form, stored using its canonical parametrization, excluding the constant.\n\nFields:\n\nΔh: canonical parameter vector of the message residual\nΔJ: canonical parameter matrix of the message residual\nkldiv: kl divergence between the message that was last sent and the  sepset belief before the last update\niscalibrated_resid: true if the last message and prior sepset belief were approximately equal, false otherwise. see iscalibrated_residnorm!\niscalibrated_kl: same, but in terms of the KL divergence, see iscalibrated_kl!.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.MessageResidual-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T<:Real","page":"Home","title":"PhyloGaussianBeliefProp.MessageResidual","text":"MessageResidual(J::AbstractMatrix{T}, h::AbstractVector{T})\n\nConstructor to allocate memory for a MessageResidual with canonical parameters (ΔJ, Δh) of the same dimension and type as J and h, initialized to zeros. kldiv is initalized to [-1.0] and the flags iscalibrated_{resid,kl} are initialized to false if the message is of positive dimension. If the message is empty (ΔJ and Δh of dimension 0) then the message is initialized as being calibrated: kldiv is set to 0 and iscalibrated flags set to true.\n\n(ΔJ, Δh) of zero suggest calibration, but the flags iscalibrated_{resid,kl} being false indicate otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.MvDiagBrownianMotion","page":"Home","title":"PhyloGaussianBeliefProp.MvDiagBrownianMotion","text":"MvDiagBrownianMotion{T,V} <: HomogeneousBrownianMotion{T}\n\nThe multivariate Brownian motion with diagonal variance rate matrix, that is, traits with independent evolution. It is homogeneous across the phylogeny. R is the variance rate (stored as a vector of type V), μ is the prior mean at the root and v the prior variance at the root, 0 by default (and both also of type V)\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.MvFullBrownianMotion","page":"Home","title":"PhyloGaussianBeliefProp.MvFullBrownianMotion","text":"MvFullBrownianMotion{T,P1,V,P2} <: HomogeneousBrownianMotion{T}\n\nThe full multivariate Brownian motion. It is homogeneous across the phylogeny. R is the variance rate (of matrix type P1), μ is the prior mean at the root (of vector type V) and v the prior variance at the root, 0 by default (of matrix type P2).\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.MvFullBrownianMotion-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}, Tuple{AbstractVector{T}, Any, Any}} where T","page":"Home","title":"PhyloGaussianBeliefProp.MvFullBrownianMotion","text":"MvFullBrownianMotion(R::AbstractMatrix, μ, v=nothing)\nMvFullBrownianMotion(U::AbstractVector, μ, v=nothing)\n\nConstructor for a full multivariate Brownian motion (homogeneous) with variance rate matrix V and prior mean vector μ at the root. If not provided, the prior variance matrix at the root v is set to 0.\n\nIf a vector U is provided, it is used as the Upper cholesky factor of R=U'U, vectorized, so U should be of length p(p+1)/2 where p is the number of traits (also the length of μ).\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.PaintedParameter","page":"Home","title":"PhyloGaussianBeliefProp.PaintedParameter","text":"PaintedParameter{T}\n\nType with 2 fields:\n\nparameter: vector whose elements are of type T\ncolor: DefaultDict dictionary mapping integers to integers, with a default value of 1.\n\nncolors(pp) returns the number of parameters, that is, the length of pp.parameter This type is meant to store several values for a given evolutionary parameter (say, Brownian motion variance rate), each one being used on some edges or nodes of a phylogenetic network. The default parameter value is the first one.\n\nFor an edge number i, color j=pp.color[i] indexes its parameter value, that is, evolution along edge number i should use pp.parameter[j]. This parameter value is obtained with getparameter(pp, j) for the parameter value of color j, or getparameter(pp, edge) for the parameter value of edge.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.UnivariateBrownianMotion","page":"Home","title":"PhyloGaussianBeliefProp.UnivariateBrownianMotion","text":"UnivariateBrownianMotion{T} <: HomogeneousBrownianMotion{T}\n\nThe univariate Brownian motion, homogeneous across the phylogeny, that is, with the same variance rate σ2 across all edges. μ is the prior mean at the root. v the prior variance at the root, 0 by default.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.UnivariateOrnsteinUhlenbeck","page":"Home","title":"PhyloGaussianBeliefProp.UnivariateOrnsteinUhlenbeck","text":"UnivariateOrnsteinUhlenbeck{T} <: HomogeneousOrnsteinUhlenbeck{T}\n\nThe univariate Ornstein-Uhlenbeck model. It is homogeneous, that is, has the same parameters across all edges in the phylogeny. σ2 is the variance rate, α the selection strength, θ the optimal value, μ the prior mean at the root, and v the prior variance at the root, 0 by default.\n\n\n\n\n\n","category":"type"},{"location":"#PhyloGaussianBeliefProp.absorbevidence!-NTuple{5, Any}","page":"Home","title":"PhyloGaussianBeliefProp.absorbevidence!","text":"absorbevidence!(h,J,g, dataindex, datavalues)\n\nAbsorb evidence, at indices dataindex and using datavalues. Warnings:\n\na subset of h is modified in place\ntraits are assumed to come in the same order in dataindex as in datavalues.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.absorbleaf!-NTuple{5, Any}","page":"Home","title":"PhyloGaussianBeliefProp.absorbleaf!","text":"absorbleaf!(h,J,g, rowindex, columntable)\n\nAbsorb evidence from a leaf, given in col[rowindex] of each column in the table, then marginalizes out any variable for a missing trait at that leaf. See absorbevidence! and marginalizebelief. Warning: The leaf traits are assumed to correspond to the first variables in h (and J), as is output by factor_treeedge.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.addtreenode_belowdegeneratehybrid!-Tuple{PhyloNetworks.HybridNetwork}","page":"Home","title":"PhyloGaussianBeliefProp.addtreenode_belowdegeneratehybrid!","text":"addtreenode_belowdegeneratehybrid!(net::HybridNetwork)\n\nIf a degenerate hybrid node h1 has 1 child edge of length t>0 to a hybrid child h2: break the edge by adding a tree node at distance t from h1 and 0 from h2. That way, h1 may be removed from scope. This is done iteratively, as h2 may become degenerate after this operation. See shrinkdegenerate_treeedges to remove degenerate internal tree nodes, and hasdegenerate to check if net still has degenerate nodes.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.assign!-Union{Tuple{T}, Tuple{Dict{T, Array{Vector{T}, 1}}, Vector{T}, T}} where T<:Integer","page":"Home","title":"PhyloGaussianBeliefProp.assign!","text":"assign!(bucket, new_minibucket, max_minibucket_size)\n\nMerge new_minibucket with one of the minibuckets contained in bucket (in order of decreasing size) subject to the constraint that the resulting minibucket does not exceed max_minibucket_size. If this is not possible, then new_minibucket is added to bucket as a new minibucket. The bucket should be represented as a dictionary: minibucket_size => vector of minibuckets of that size, where each minibucket is itself represented as a vector of indices.\n\nOutput:\n\n(resulting_minibucket, minibucket_merged_into) if a successful merge is found\n(new_minibucket, []) otherwise\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.average_energy","page":"Home","title":"PhyloGaussianBeliefProp.average_energy","text":"average_energy!(ref::Belief, target::AbstractBelief)\naverage_energy!(ref::Belief, Jₜ, hₜ, gₜ)\naverage_energy(Jᵣ::Union{LA.Cholesky,PDMat}, μᵣ, Jₜ, hₜ, gₜ)\n\nAverage energy (i.e. negative expected log) of a target canonical form with parameters (Jₜ, hₜ, gₜ) with respect to a normalized non-degenerate reference canonical form ref with parameters (Jᵣ, hᵣ). The reference distribution is normalized, so specifying gᵣ is unnecessary. When the target canonical form is also normalized and non-degenerate, this is equal to their cross-entropy:\n\nH(fᵣ, fₜ) = - Eᵣ(log fₜ) = - ∫ fᵣ log fₜ .\n\nref is assumed to be non-degenerate, that is, Jᵣ should be positive definite.\n\naverage_energy! modifies the reference belief by updating ref.μ to J⁻¹h. It calls average_energy after a cholesky decomposition of ref.J, stored in Jᵣ: see getcholesky_μ!.\n\nCalculation:\n\nref: f(x) = C(x | Jᵣ, hᵣ, _) is the density of 𝒩(μ=Jᵣ⁻¹hᵣ, Σ=Jᵣ⁻¹)   target: C(x | Jₜ, hₜ, gₜ) = exp( - (1/2)x'Jₜx + hₜ'x + gₜ )\n\nE[-log C(X | Jₜ, hₜ, gₜ)] where X ∼ C(Jᵣ, hᵣ, _)\n= 0.5 (μᵣ'Jₜ μᵣ + tr(Jᵣ⁻¹Jₜ)) - hₜ'μᵣ - gₜ\n\nWith empty vectors and matrices (J's of dimension 0×0 and h's of length 0), the result is simply: - gₜ.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.average_energy!-Tuple{PhyloGaussianBeliefProp.Belief, PhyloGaussianBeliefProp.AbstractBelief}","page":"Home","title":"PhyloGaussianBeliefProp.average_energy!","text":"average_energy!(ref::Belief, target::AbstractBelief)\naverage_energy!(ref::Belief, Jₜ, hₜ, gₜ)\naverage_energy(Jᵣ::Union{LA.Cholesky,PDMat}, μᵣ, Jₜ, hₜ, gₜ)\n\nAverage energy (i.e. negative expected log) of a target canonical form with parameters (Jₜ, hₜ, gₜ) with respect to a normalized non-degenerate reference canonical form ref with parameters (Jᵣ, hᵣ). The reference distribution is normalized, so specifying gᵣ is unnecessary. When the target canonical form is also normalized and non-degenerate, this is equal to their cross-entropy:\n\nH(fᵣ, fₜ) = - Eᵣ(log fₜ) = - ∫ fᵣ log fₜ .\n\nref is assumed to be non-degenerate, that is, Jᵣ should be positive definite.\n\naverage_energy! modifies the reference belief by updating ref.μ to J⁻¹h. It calls average_energy after a cholesky decomposition of ref.J, stored in Jᵣ: see getcholesky_μ!.\n\nCalculation:\n\nref: f(x) = C(x | Jᵣ, hᵣ, _) is the density of 𝒩(μ=Jᵣ⁻¹hᵣ, Σ=Jᵣ⁻¹)   target: C(x | Jₜ, hₜ, gₜ) = exp( - (1/2)x'Jₜx + hₜ'x + gₜ )\n\nE[-log C(X | Jₜ, hₜ, gₜ)] where X ∼ C(Jᵣ, hᵣ, _)\n= 0.5 (μᵣ'Jₜ μᵣ + tr(Jᵣ⁻¹Jₜ)) - hₜ'μᵣ - gₜ\n\nWith empty vectors and matrices (J's of dimension 0×0 and h's of length 0), the result is simply: - gₜ.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.betheclustergraph-Tuple{PhyloNetworks.HybridNetwork}","page":"Home","title":"PhyloGaussianBeliefProp.betheclustergraph","text":"betheclustergraph(net)\n\nSee Bethe\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.branch_actualization-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.EvolutionaryModel{T}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}} where T","page":"Home","title":"PhyloGaussianBeliefProp.branch_actualization","text":"branch_actualization(obj::EvolutionaryModel, edge::PN.Edge) \nbranch_displacement(obj::EvolutionaryModel,  edge::PN.Edge)\nbranch_precision(obj::EvolutionaryModel,     edge::PN.Edge)\nbranch_variance(obj::EvolutionaryModel,      edge::PN.Edge)\nbranch_logdet(obj::EvolutionaryModel,        edge::PN.Edge, precision::AbstractMatrix)\nbranch_transition_qωjg(obj::EvolutionaryModel,    edge)\nbranch_transition_qωv!(q, obj::EvolutionaryModel, edge)\n\nUnder the most general linear Gaussian model, X₀ given X₁ is Gaussian with conditional mean q X₁ + ω and conditional variance Σ independent of X₁. branch_actualization, branch_displacement and branch_variance return, respectively, q, ω and Σ. branch_precision and branch_variance should return a matrix of symmetric type. branch_variance defaults to the inverse of branch_precision. branch_logdet defaults to g = -0.5*log(|2πΣ|), the log normalizing constant of the Gaussian density in the traditional form. branch_transition_* return or modify in place the corresponding transition matrices.\n\nUnder a Brownian motion, we have q=I, ω=0, and conditional variance t*R where R is the model's variance rate and t the branch length.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.branch_displacement","page":"Home","title":"PhyloGaussianBeliefProp.branch_displacement","text":"branch_actualization(obj::EvolutionaryModel, edge::PN.Edge) \nbranch_displacement(obj::EvolutionaryModel,  edge::PN.Edge)\nbranch_precision(obj::EvolutionaryModel,     edge::PN.Edge)\nbranch_variance(obj::EvolutionaryModel,      edge::PN.Edge)\nbranch_logdet(obj::EvolutionaryModel,        edge::PN.Edge, precision::AbstractMatrix)\nbranch_transition_qωjg(obj::EvolutionaryModel,    edge)\nbranch_transition_qωv!(q, obj::EvolutionaryModel, edge)\n\nUnder the most general linear Gaussian model, X₀ given X₁ is Gaussian with conditional mean q X₁ + ω and conditional variance Σ independent of X₁. branch_actualization, branch_displacement and branch_variance return, respectively, q, ω and Σ. branch_precision and branch_variance should return a matrix of symmetric type. branch_variance defaults to the inverse of branch_precision. branch_logdet defaults to g = -0.5*log(|2πΣ|), the log normalizing constant of the Gaussian density in the traditional form. branch_transition_* return or modify in place the corresponding transition matrices.\n\nUnder a Brownian motion, we have q=I, ω=0, and conditional variance t*R where R is the model's variance rate and t the branch length.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.branch_precision","page":"Home","title":"PhyloGaussianBeliefProp.branch_precision","text":"branch_actualization(obj::EvolutionaryModel, edge::PN.Edge) \nbranch_displacement(obj::EvolutionaryModel,  edge::PN.Edge)\nbranch_precision(obj::EvolutionaryModel,     edge::PN.Edge)\nbranch_variance(obj::EvolutionaryModel,      edge::PN.Edge)\nbranch_logdet(obj::EvolutionaryModel,        edge::PN.Edge, precision::AbstractMatrix)\nbranch_transition_qωjg(obj::EvolutionaryModel,    edge)\nbranch_transition_qωv!(q, obj::EvolutionaryModel, edge)\n\nUnder the most general linear Gaussian model, X₀ given X₁ is Gaussian with conditional mean q X₁ + ω and conditional variance Σ independent of X₁. branch_actualization, branch_displacement and branch_variance return, respectively, q, ω and Σ. branch_precision and branch_variance should return a matrix of symmetric type. branch_variance defaults to the inverse of branch_precision. branch_logdet defaults to g = -0.5*log(|2πΣ|), the log normalizing constant of the Gaussian density in the traditional form. branch_transition_* return or modify in place the corresponding transition matrices.\n\nUnder a Brownian motion, we have q=I, ω=0, and conditional variance t*R where R is the model's variance rate and t the branch length.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.branch_variance","page":"Home","title":"PhyloGaussianBeliefProp.branch_variance","text":"branch_actualization(obj::EvolutionaryModel, edge::PN.Edge) \nbranch_displacement(obj::EvolutionaryModel,  edge::PN.Edge)\nbranch_precision(obj::EvolutionaryModel,     edge::PN.Edge)\nbranch_variance(obj::EvolutionaryModel,      edge::PN.Edge)\nbranch_logdet(obj::EvolutionaryModel,        edge::PN.Edge, precision::AbstractMatrix)\nbranch_transition_qωjg(obj::EvolutionaryModel,    edge)\nbranch_transition_qωv!(q, obj::EvolutionaryModel, edge)\n\nUnder the most general linear Gaussian model, X₀ given X₁ is Gaussian with conditional mean q X₁ + ω and conditional variance Σ independent of X₁. branch_actualization, branch_displacement and branch_variance return, respectively, q, ω and Σ. branch_precision and branch_variance should return a matrix of symmetric type. branch_variance defaults to the inverse of branch_precision. branch_logdet defaults to g = -0.5*log(|2πΣ|), the log normalizing constant of the Gaussian density in the traditional form. branch_transition_* return or modify in place the corresponding transition matrices.\n\nUnder a Brownian motion, we have q=I, ω=0, and conditional variance t*R where R is the model's variance rate and t the branch length.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.calibrate!","page":"Home","title":"PhyloGaussianBeliefProp.calibrate!","text":"calibrate!(beliefs::ClusterGraphBelief, scheduletree::Tuple,\n    verbose::Bool=true, up_resnorm::Bool=true, up_reskldiv::Bool=false)\n\nPropage messages along the scheduletree, in postorder then preorder: see propagate_1traversal_postorder!.\n\nOutput: true if all message residuals have a small norm, based on iscalibrated_residnorm, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.calibrate!-2","page":"Home","title":"PhyloGaussianBeliefProp.calibrate!","text":"calibrate!(beliefs::ClusterGraphBelief, schedule, niterations=1;\n    auto::Bool=false, info::Bool=false,\n    verbose::Bool=true,\n    update_residualnorm::Bool=true,\n    update_residualkldiv::Bool=false)\n\nPropagate messages in postorder then preorder for each tree in the schedule list, for niterations. Each schedule \"tree\" should be a tuple of 4 vectors as output by spanningtree_clusterlist, where each vector provides the parent/child label/index of an edge along which to pass a message, and where these edges are listed in preorder. For example, the parent of the first edge is taken to be the root of the schedule tree. Calibration is evaluated after each schedule tree is run, and said to be reached if all message residuals have a small norm, based on iscalibrated_residnorm.\n\nOutput: true if calibration is reached, false otherwise.\n\nOptional keyword arguments:\n\nauto: If true, then belief updates are stopped after calibration is found to be reached. Otherwise belief updates continue for the full number of iterations.\ninfo: Is true, information is logged with the iteration number and schedule tree index when calibration is reached.\nverbose: log error messages about degenerate messages\nupdate_residualnorm\nupdate_residualkldiv\n\nSee also: iscalibrated_residnorm and iscalibrated_residnorm! for the tolerance and norm used by default, to declare calibration for a given sepset message (in 1 direction).\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.calibrate_exact_cliquetree!-Union{Tuple{B}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief{B}, Any, Vector{PhyloNetworks.Node}, NamedTuple{names, T} where {N, names, T<:Tuple{Vararg{AbstractVector, N}}}, AbstractVector, Any}} where {T, B<:(PhyloGaussianBeliefProp.Belief{T, Vlabel, P, V} where {Vlabel<:(AbstractVector), P<:AbstractMatrix{T}, V<:AbstractVector{T}})}","page":"Home","title":"PhyloGaussianBeliefProp.calibrate_exact_cliquetree!","text":"calibrate_exact_cliquetree!(beliefs::ClusterGraphBelief,\n    schedule,\n    nodevector_preordered,\n    tbl::Tables.ColumnTable, taxa::AbstractVector,\n    evolutionarymodel_name)\n\nFor a Brownian Motion with a fixed root, compute the maximum likelihood estimate of the prior mean at the root and the restricted maximum likelihood (REML) estimate of the variance/covariance rate matrix using analytical formulas relying on belief propagation, using the data in tbl at leaves in the network. These estimates are for the model with a prior variance of 0 at the root, that is, a root state equal to the prior mean.\n\noutput: (bestmodel, loglikelihood_score) where bestmodel is an evolutionary model created by evolutionarymodel_name, containing the estimated model parameters.\n\nassumptions:\n\ntaxa should list the taxon names in the same order in which they come in the rows of tbl.\nschedule should provide a schedule to transmit messages between beliefs in beliefs (containing clusters first then sepsets). This schedule is assumed to traverse a clique tree for the input phylogeny, with the root cluster containing the root of the phylogeny in its scope.\nnodevector_preordered should list the nodes in this phylogeny, in preorder.\nbeliefs should be of size and scope consistent with evolutionarymodel_name and data in tbl.\na leaf should either have complete data, or be missing data for all traits.\n\nSteps:\n\nCalibrate beliefs in place according to the schedule, under a model with an infinite prior variance at the root.\nEstimate parameters analytically.\nRe-calibrate beliefs, to calculate the maximum log-likelihood of the fixed-root model at the estimated optimal parameters, again modifying beliefs in place. (Except that beliefs with the root node in scope are re-assigned to change their scoping dimension.)\n\nWarning: there is no check that the beliefs and schedule are consistent with each other.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.calibrate_optimize_cliquetree!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, Any, Vector{PhyloNetworks.Node}, NamedTuple{names, T} where {N, names, T<:Tuple{Vararg{AbstractVector, N}}}, AbstractVector, Any, Any}","page":"Home","title":"PhyloGaussianBeliefProp.calibrate_optimize_cliquetree!","text":"calibrate_optimize_cliquetree!(beliefs::ClusterGraphBelief, clustergraph,\n    nodevector_preordered, tbl::Tables.ColumnTable, taxa::AbstractVector,\n    evolutionarymodel_name, evolutionarymodel_startingparameters)\n\nOptimize model parameters using belief propagation along clustergraph, assumed to be a clique tree for the input network, whose nodes in preorder are nodevector_preordered. Optimization aims to maximize the likelihood of the data in tbl at leaves in the network. The taxon names in taxa should appear in the same order as they come in tbl. The parameters being optimized are the variance rate(s) and prior mean(s) at the root. The prior variance at the root is fixed.\n\nThe calibration does a postorder of the clique tree only, to get the likelihood at the root without the conditional distribution at all nodes, modifying beliefs in place. Therefore, if the distribution of ancestral states is sought, an extra preorder calibration would be required. Warning: there is no check that the cluster graph is in fact a clique tree.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.calibrate_optimize_clustergraph!","page":"Home","title":"PhyloGaussianBeliefProp.calibrate_optimize_clustergraph!","text":"calibrate_optimize_clustergraph!(beliefs::ClusterGraphBelief, clustergraph,\n    nodevector_preordered, tbl::Tables.ColumnTable, taxa::AbstractVector,\n    evolutionarymodel_name, evolutionarymodel_startingparameters,\n    max_iterations=100)\n\nSame as calibrate_optimize_cliquetree! above, except that the user can supply an arbitrary clustergraph (including a clique tree) for the input network. Optimization aims to maximize the factored_energy approximation to the ELBO for the log-likelihood of the data (which is also the negative Bethe free_energy). When clustergraph is a clique tree, the factored energy approximation is exactly equal to the ELBO and the log-likelihood.\n\nCluster beliefs are regularized using regularizebeliefs_bycluster! (other options are likely to be available in future versions) before calibration. The calibration repeatedly loops through a minimal set of spanning trees (see spanningtrees_clusterlist) that covers all edges in the cluster graph, and does a postorder-preorder traversal for each tree. The loop runs till calibration is detected or till max_iterations have passed, whichever occurs first.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.check_runningintersection-Tuple{MetaGraphsNext.MetaGraph, PhyloNetworks.HybridNetwork}","page":"Home","title":"PhyloGaussianBeliefProp.check_runningintersection","text":"check_runningintersection(clustergraph, net)\n\nVector of tuples. Each tuple is of the form (nodelabel, istree), where nodelabel::Symbol is the label of a node in net and istree is true (false) if the node's cluster subgraph is (is not) a tree. This \"cluster subgraph\" for a given node is the subgraph of clustergraph induced by the clusters containing the node and by the edges whose sepset contain the node: see nodesubtree.\n\nclustergraph satisfies the generalized running-intersection property if istree is true for all nodes in net.\n\nWarning:\n\nassumes that net has been preordered, and\ndoes not check if clustergraph has been correctly constructed.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.cliquetree-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T","page":"Home","title":"PhyloGaussianBeliefProp.cliquetree","text":"cliquetree(chordal_graph)\n\nClique tree U for an input graph g assumed to be chordal (triangulated), e.g. using triangulate_minfill!.   Warning: does not check that the graph is already triangulated.\n\nEach node in U is a maximal clique of g whose data is the tuple of vectors (nodelabels, nodedata) using the labels and data from g, with nodes sorted by decreasing data. If g was originally built from a phylogenetic network using moralize, then the nodes' data are their preorder index, making them sorted in postorder within in each clique. The clique label is the concatenation of the node labels.\nFor each edge (clique1, clique2) in U, the edge data hold the sepset (separating set) information as a vector of node data, for nodes shared by both clique1 and clique2. In this sepset, nodes are sorted by decreasing data.\n\nUses maximal_cliques and kruskal_mst (for min/maximum spanning trees) from Graphs.jl.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.clustergraph","page":"Home","title":"PhyloGaussianBeliefProp.clustergraph","text":"clustergraph!(net, method)\nclustergraph(net, method)\n\nCluster graph U for an input network net and a method of cluster graph construction. The following methods are supported:\n\nBethe\nLTRIP\nJoinGraphStructuring\nCliquetree\n\nThe first method pre-processes net, which may modify it in place, see preprocessnet!. The second method assumes that net is already pre-processed.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.clustergraph!-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.AbstractClusterGraphMethod}","page":"Home","title":"PhyloGaussianBeliefProp.clustergraph!","text":"clustergraph!(net, method)\nclustergraph(net, method)\n\nCluster graph U for an input network net and a method of cluster graph construction. The following methods are supported:\n\nBethe\nLTRIP\nJoinGraphStructuring\nCliquetree\n\nThe first method pre-processes net, which may modify it in place, see preprocessnet!. The second method assumes that net is already pre-processed.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.default_rootcluster-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}","page":"Home","title":"PhyloGaussianBeliefProp.default_rootcluster","text":"default_rootcluster(clustergraph, nodevector_preordered)\n\nIndex of a cluster that contains the network's root, whose label is assumed to be 1 (preorder index). If multiple clusters contain the network's root, then one is chosen with the smallest number of taxa (leaves in the network).\n\nFor cluster with label :lab, its property clustergraph[:lab][2] should list the nodes in the cluster, by the index of each node in nodevector_preordered such that 1 corresponds to the network's root. Typically, this vector is net.nodes_changed after the network is preordered.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.default_rootcluster-Tuple{MetaGraphsNext.MetaGraph}","page":"Home","title":"PhyloGaussianBeliefProp.default_rootcluster","text":"default_rootcluster(clustergraph)\n\nIndex of a cluster that contains the node with the smallest preorder index. If multiple clusters contain that node, then one is chosen that only has that node. If all clusters containing that node have more than 1 node, then a cluster is chosen containing a node with the second-smallest-preorder index.\n\nFor cluster with label :lab, its property clustergraph[:lab][2] should list the nodes in the cluster by their preorder index, sorted in decreasingly order (so the smallest is at the end).\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.dimension-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel}","page":"Home","title":"PhyloGaussianBeliefProp.dimension","text":"dimension(m::EvolutionaryModel)\n\nNumber of traits, e.g. 1 for univariate models.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.entropy-Union{Tuple{Union{LinearAlgebra.Cholesky{T}, PDMats.PDMat{T}}}, Tuple{T}} where T<:Real","page":"Home","title":"PhyloGaussianBeliefProp.entropy","text":"entropy(J::Cholesky)\nentropy(J::AbstractMatrix)\nentropy(belief::AbstractBelief)\n\nEntropy of a multivariate Gaussian distribution with precision matrix J, assumed to be square and symmetric (not checked). It is 0 if J is empty (of size 0×0). It may be Inf if J is semi-definite. The second version applies the first to the belief precision belief.J.\n\nentropy is defined for discrete distributions in StatsBase.jl and extended to Gaussian distributions in Distributions.jl around here\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.factor_hybridnode-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.EvolutionaryModel{T}, AbstractVector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}}} where T","page":"Home","title":"PhyloGaussianBeliefProp.factor_hybridnode","text":"factor_hybridnode(evolutionarymodel, ts::AbstractVector, γs)\nfactor_tree_degeneratehybrid(model,  t0::Real,           γs)\n\nCanonical parameters h,J,g of factor ϕ(X₀, X₁, X₂, ...) from the evolutionary model for a hybrid node: where X₀ is the state at the hybrid node and X₁, X₂, ... the states of the parent nodes. Warning: γs is modified in placed, changed to [1 -γs].\n\nIt is assumed that the conditional mean is a simple weighted average:\n\nEX_0  X_1 X_2  = sum_k gamma_k X_k = q mathrmvec(X_1X_2) + omega\n\nwhere q has one block for each parent, and each block is diagonal scalar: gamma_k I_p. More complex models could consider adding a shift ω to the conditional mean.\n\nIf all the parent hybrid edges edges have length 0, then it is assumed that the model gives a degenerate distribution, with 0 conditional variance. More complex models could consider adding a hybrid conditional variance Σ.\n\nThe first form assumes that at least 1 parent edge length is positive, with conditional variance sum_k gamma_k^2 V_k where V_k is the conditional variance from the kth parent edge.\nThe second form can be used in case all parent edges have 0 length, to integrate out the hybrid node state and the factor ϕ(X₀, X₁, X₂, ...) when X₀ is its child state, along an edge of length t0 between the hybrid node and its child. This second form is appropriate when this hybrid's child is a tree node, and t0>0.`\n\nIn h and J, the first p coordinates are for the hybrid (or its child) and the last coordinates for the parents, in the same order in which the edge lengths and γs are given.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.factor_root-Tuple{T} where T<:PhyloGaussianBeliefProp.EvolutionaryModel","page":"Home","title":"PhyloGaussianBeliefProp.factor_root","text":"factor_root(m::EvolutionaryModel)\n\nCanonical parameters h,J,g of the prior density at the root, from model m. Assumes that isrootfixed(m) returns false (in which case the root value should be absorbed as evidence and the root removed from scope). More strongly, the root variance is assumed to be invertible, in particular, traits are all non-fixed at the root.\n\nThe prior is improper if the prior variance is infinite. In this case this prior is not a distribution (total probability ≠ 1) but is taken as the constant function 1, which corresponds to h,J,g all 0 (and an irrelevant mean).\n\nIf the root variance is not invertible (e.g., fixed root), this function fails and should never be called (see isrootfixed)\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.factor_treeedge-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Home","title":"PhyloGaussianBeliefProp.factor_treeedge","text":"factor_treeedge(evolutionarymodel, edge)\n\nCanonical parameters h,J,g of factor ϕ(X0,X1) from the given evolutionary model along one edge, where X₀ is the state of the child node and X₁ the state of the parent node. In h and J, the first p coordinates are for the child and the last p for the parent, where p is the number of traits (determined by the model).\n\nUnder the most general linear Gaussian model, X₀ given X₁ is Gaussian with conditional mean q X₁ + ω and conditional variance Σ independent of X₁. The generic fallback method uses functions  branch_actualization for q,  branch_displacement for ω,  branch_precision for Σ⁻¹.\n\nUnder a Brownian motion, we have q=I, ω=0, and Σ=tR where R is the model's variance rate and t is the length of the branch. In that case, a specific (more efficient) method is implemented, and the default fallback is not used.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.factored_energy-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}","page":"Home","title":"PhyloGaussianBeliefProp.factored_energy","text":"factored_energy(beliefs::ClusterGraphBelief)\n\nFactored energy functional for general cluster graphs (Koller & Friedman 2009), which approximates the evidence lower bound (ELBO), a lower bound for the log-likelihood. It is also called the (negative) Bethe free energy in the context of factor graphs It is the sum of the cluster average energies and entropies, minus the sepset entropies. It is assumed but not checked that beliefs are calibrated (neighbor clusters and sepset beliefs are consistent, used as local marginals).\n\nFor a calibrated clique tree, the factored energy is equal to the log-likelihood. For a calibrated cluster graph, it can serve as as approximation.\n\noutput: tuple of 3 values, the 3rd being the factored energy: (average energy, approximate entropy, factored energy = -energy + entropy).\n\nSee also: free_energy, entropy, average_energy!\n\nReferences\n\nD. Koller and N. Friedman. Probabilistic graphical models: principles and techniques. MIT Press, 2009. ISBN 9780262013192.\n\nD. M. Blei, A. Kucukelbir, and J. D. McAuliffe. Variational inference: A Review for Statisticians, Journal of the American statistical Association, 112:518, 859-877, 2017, doi: 10.1080/01621459.2017.1285773.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.free_energy-Union{Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief{B}}, Tuple{B}, Tuple{T}} where {T<:Real, B<:(PhyloGaussianBeliefProp.Belief{T, Vlabel, P, V} where {Vlabel<:(AbstractVector), P<:AbstractMatrix{T}, V<:AbstractVector{T}})}","page":"Home","title":"PhyloGaussianBeliefProp.free_energy","text":"free_energy(beliefs::ClusterGraphBelief)\n\nnegative factored_energy to approximate the negative log-likelihood. The approximation is exact on a clique tree after calibration.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.getcholesky-Tuple{AbstractMatrix}","page":"Home","title":"PhyloGaussianBeliefProp.getcholesky","text":"getcholesky(J::AbstractMatrix)\n\nCholesky decomposition of J, assumed to be symmetric positive definite, stored as a PDMat object. Warning: PDMat is not a subtype of Cholesky. PDMats.jl is efficient for structured matrices (e.g diagonal or sparse) and has efficient methods for linear algebra, e.g. \\, invquad, X_invA_Xt etc.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.getcholesky_μ!","page":"Home","title":"PhyloGaussianBeliefProp.getcholesky_μ!","text":"getcholesky_μ(J::AbstractMatrix, h)\ngetcholesky_μ!(belief::Belief)\n\nTuple (Jchol, μ) where Jchol is a cholesky representation of J or belief.J and μ is J⁻¹h, used to update belief.μ (by the second method).\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.getcholesky_μ-Tuple{AbstractMatrix, Any}","page":"Home","title":"PhyloGaussianBeliefProp.getcholesky_μ","text":"getcholesky_μ(J::AbstractMatrix, h)\ngetcholesky_μ!(belief::Belief)\n\nTuple (Jchol, μ) where Jchol is a cholesky representation of J or belief.J and μ is J⁻¹h, used to update belief.μ (by the second method).\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.hasdegenerate-Tuple{PhyloNetworks.HybridNetwork}","page":"Home","title":"PhyloGaussianBeliefProp.hasdegenerate","text":"hasdegenerate(net)\n\ntrue if degenerate nodes remain in scope, that is, if there exists a tree edge of length 0, or if there exists a hybrid node with all parent edges of length 0 and with 2 or more children edges, or with 1 child edge of length 0.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.hybridnode_displacement-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.EvolutionaryModel{T}, AbstractVector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}}} where T","page":"Home","title":"PhyloGaussianBeliefProp.hybridnode_displacement","text":"hybridnode_displacement(obj::EvolutionaryModel, parentedges::AbstractVector{PN.Edge})\nhybridnode_precision(obj::EvolutionaryModel,    parentedges::AbstractVector{PN.Edge})\nhybridnode_variance(obj::EvolutionaryModel,     parentedges::AbstractVector{PN.Edge})\n\nUnder the most general weighted average Gaussian model, X₀ given its parents X₁, X₂, ... is Gaussian with conditional mean the weighted average of the parents plus a displacement vector ω and conditional variance Σ independent of X₁, X₂, ... . The weights are given by the inheritance probabilities contained in the PN.Edge objects. hybridnode_displacement and hybridnode_variance return, respectively, ω and Σ.\n\nhybridnode_variance and hybridnode_precision should return a matrix of symmetric type. hybridnode_precision defaults to the inverse of hybridnode_variance. hybridnode_displacement and hybridnode_variance default to a vector or matrix of zeros. \n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.hybridnode_precision","page":"Home","title":"PhyloGaussianBeliefProp.hybridnode_precision","text":"hybridnode_displacement(obj::EvolutionaryModel, parentedges::AbstractVector{PN.Edge})\nhybridnode_precision(obj::EvolutionaryModel,    parentedges::AbstractVector{PN.Edge})\nhybridnode_variance(obj::EvolutionaryModel,     parentedges::AbstractVector{PN.Edge})\n\nUnder the most general weighted average Gaussian model, X₀ given its parents X₁, X₂, ... is Gaussian with conditional mean the weighted average of the parents plus a displacement vector ω and conditional variance Σ independent of X₁, X₂, ... . The weights are given by the inheritance probabilities contained in the PN.Edge objects. hybridnode_displacement and hybridnode_variance return, respectively, ω and Σ.\n\nhybridnode_variance and hybridnode_precision should return a matrix of symmetric type. hybridnode_precision defaults to the inverse of hybridnode_variance. hybridnode_displacement and hybridnode_variance default to a vector or matrix of zeros. \n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.hybridnode_variance","page":"Home","title":"PhyloGaussianBeliefProp.hybridnode_variance","text":"hybridnode_displacement(obj::EvolutionaryModel, parentedges::AbstractVector{PN.Edge})\nhybridnode_precision(obj::EvolutionaryModel,    parentedges::AbstractVector{PN.Edge})\nhybridnode_variance(obj::EvolutionaryModel,     parentedges::AbstractVector{PN.Edge})\n\nUnder the most general weighted average Gaussian model, X₀ given its parents X₁, X₂, ... is Gaussian with conditional mean the weighted average of the parents plus a displacement vector ω and conditional variance Σ independent of X₁, X₂, ... . The weights are given by the inheritance probabilities contained in the PN.Edge objects. hybridnode_displacement and hybridnode_variance return, respectively, ω and Σ.\n\nhybridnode_variance and hybridnode_precision should return a matrix of symmetric type. hybridnode_precision defaults to the inverse of hybridnode_variance. hybridnode_displacement and hybridnode_variance default to a vector or matrix of zeros. \n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.init_beliefs_allocate-Union{Tuple{T}, Tuple{NamedTuple{names, T} where {N, names, T<:Tuple{Vararg{AbstractVector, N}}}, AbstractVector, PhyloNetworks.HybridNetwork, Any, PhyloGaussianBeliefProp.EvolutionaryModel{T}}} where T","page":"Home","title":"PhyloGaussianBeliefProp.init_beliefs_allocate","text":"init_beliefs_allocate(tbl::Tables.ColumnTable, taxa, net, clustergraph,\n                      evolutionarymodel)\n\nVector of beliefs, initialized to the constant function exp(0)=1, one for each cluster then one for each sepset in clustergraph. tbl is used to know which leaf in net has data for which trait, so as to remove from the scope each variable without data below it. taxa should be a vector with taxon names in the same order as they come in the table of data tbl. The root is removed from scope if the evolutionary model has a fixed root: so as to use the model's fixed root value as data if the root as zero prior variance. Also removed from scope is any hybrid node that is degenerate and who has a single child edge of positive length.\n\nWarnings: this function might need to be re-run to re-do allocation if\n\nthe data changed: different number of traits, or different pattern of missing data at the tips\nthe model changed: with the root changed from fixed to random, see init_beliefs_allocate_atroot! in that case.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.init_beliefs_allocate_atroot!-Union{Tuple{T}, Tuple{Any, Any, Any, PhyloGaussianBeliefProp.EvolutionaryModel{T}}} where T","page":"Home","title":"PhyloGaussianBeliefProp.init_beliefs_allocate_atroot!","text":"init_beliefs_allocate_atroot!(beliefs, factors, messageresiduals, model)\n\nUpdate the scope and re-allocate memory for cluster & sepset beliefs, factors and messageresiduals to include or exclude the root, depending on whether the root variable is random or fixed in model. To change the dimension of canonical parameters μ,h,J, new memory is allocated and initilized to 0. This function can be used to update beliefs when the root model changes from fixed to non-fixed or vice-versa. It re-allocates less memory than init_beliefs_allocate (which would need to be followed by init_factors_allocate) because clusters and sepsets that do not have the root are not modified.\n\nAssumptions:\n\nall traits at the root have at least one descendant with non-missing data,\nbeliefs were previously initialized with a model that had the same number of traits as the current model.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.init_beliefs_assignfactors!-Tuple{Vector{<:PhyloGaussianBeliefProp.Belief}, PhyloGaussianBeliefProp.EvolutionaryModel, NamedTuple{names, T} where {N, names, T<:Tuple{Vararg{AbstractVector, N}}}, AbstractVector, Vector{PhyloNetworks.Node}}","page":"Home","title":"PhyloGaussianBeliefProp.init_beliefs_assignfactors!","text":"init_beliefs_assignfactors!(beliefs,\n                            evolutionarymodel, columntable, taxa,\n                            nodevector_preordered)\n\nInitialize cluster beliefs prior to belief propagation, by assigning each factor to one cluster. Sepset beliefs are reset to 0. There is one factor for each node v in the vector of nodes: the density of X_v conditional on its parent X_pa(v) if v is not the root, or the prior density for X_root.\n\nfor each leaf, the factor is reduced by absorbing the evidence for that leaf, that is, the data found in the columntable, whose rows should be ordered by taxa as they appear in taxa.\nfor each leaf, missing trait values are removed from scope.\nfor each internal node, any trait not in scope (e.g. if all descendant leaves are missing a value for this trait) is marginalized out of the factor.\n\nAssumptions:\n\nIn vector nodevector_preordered, nodes are assumed to be preordered. Typically, this vector is net.nodes_changed after the network is preordered.\nBelief node labels correspond to the index of each node in nodevector_preordered.\nIn beliefs, cluster beliefs come first and sepset beliefs come last, as when created by init_beliefs_allocate\n\nOutput: vector node2belief such that, if i is the preorder index of a node in the network, node2belief[i] is the index of the belief that the node family was assigned to.\n\nThe beliefs vector is modified in place.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.init_beliefs_reset!-Union{Tuple{AbstractVector{B}}, Tuple{B}, Tuple{T}} where {T, B<:(PhyloGaussianBeliefProp.Belief{T, Vlabel, P, V} where {Vlabel<:(AbstractVector), P<:AbstractMatrix{T}, V<:AbstractVector{T}})}","page":"Home","title":"PhyloGaussianBeliefProp.init_beliefs_reset!","text":"init_beliefs_reset!(beliefs::Vector{<:Belief})\n\nReset all beliefs (which can be cluster and/or sepset beliefs) to h=0, J=0, g=0 (μ unchanged). They can later be re-initialized for different model parameters and re-calibrated, without re-allocating memory.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.init_beliefs_reset_fromfactors!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}","page":"Home","title":"PhyloGaussianBeliefProp.init_beliefs_reset_fromfactors!","text":"init_beliefs_reset_fromfactors!(beliefs::ClusterGraphBelief)\n\nReset cluster beliefs to existing factors, and sepset beliefs to h=0, J=0, g=0\n\nThis is not used so far, as changing model parameters requires a reset of both factors and beliefs, done by init_beliefs_assignfactors!.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.init_clustergraph-Tuple{Type{<:Integer}, Symbol}","page":"Home","title":"PhyloGaussianBeliefProp.init_clustergraph","text":"init_clustergraph(T::Type{<:Integer}, clustergraph_method::Symbol)\n\nMetaGraph with an empty base graph (0 vertices, 0 edges), meta-graph data clustergraph_method, edge-weight function counting the length of the edge-data vector, and the following types:\n\nvertex indices in the base graph: T\nvertex labels: Symbol\nvertex data: Tuple{Vector{Symbol}, Vector{T}} to hold information about the variables (nodes in phylogenetic network) in the cluster (vertex in cluster graph): node names as symbols, and node preorder indices\nedge data: Vector{T} to hold information about the sepset: preorder index of nodes in the sepset.\n\nSee packages MetaGraphsNext and Graphs.\n\nThe empty graph above is of type Graphs.SimpleGraphs.SimpleGraph{T}: undirected, with vertex indices of type T. After addition of n vertices, the vertex indices range from 1 to n, technically in Base.OneTo{T}(n).\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.init_factors_allocate-Union{Tuple{B}, Tuple{T}, Tuple{AbstractVector{B}, Integer}} where {T, B<:(PhyloGaussianBeliefProp.Belief{T, Vlabel, P, V} where {Vlabel<:(AbstractVector), P<:AbstractMatrix{T}, V<:AbstractVector{T}})}","page":"Home","title":"PhyloGaussianBeliefProp.init_factors_allocate","text":"init_factors_allocate(beliefs::AbstractVector{<:Belief}, nclusters::Integer)\n\nVector of nclusters factors of type FamilyFactor, whose canonical parameters and metadata are initialized to be a copy of those in beliefs. Assumption: beliefs[1:nclusters] are cluster beliefs, and beliefs[nclusters+1:end] (if any) are sepset beliefs. This is not checked.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.init_factors_frombeliefs!","page":"Home","title":"PhyloGaussianBeliefProp.init_factors_frombeliefs!","text":"init_factors_frombeliefs!(factors, beliefs, checkmetadata::Bool=false)\n\nReset all factors by copying h,J,g from beliefs. Assumption: the cluster beliefs match the factors exactly: for a valid factor index i, beliefs[i] is of cluster type and has the same dimension as factors[i].\n\nSet checkmetadata to true to check that beliefs[i] and factors[i] have the same metadata.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!","page":"Home","title":"PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!","text":"init_messagecalibrationflags_reset!(beliefs::ClusterGraphBelief, reset_kl=true)\n\nReset all non-empty message residuals in beliefs.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Bool}} where T","page":"Home","title":"PhyloGaussianBeliefProp.init_messagecalibrationflags_reset!","text":"init_messagecalibrationflags_reset!(mr::AbstractResidual, reset_kl::Bool)\n\nFor a non-empty message residual mr, reset its iscalibrated_* flags to false, and if reset_kl is true, reset its kldiv to -1. Its ΔJ and Δh fields are not reset here, because they are overwritten during a belief propagation step. Nothing is done for empty messages.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.init_messageresidual_allocate-Union{Tuple{B}, Tuple{T}, Tuple{Vector{B}, Any}} where {T<:Real, B<:(PhyloGaussianBeliefProp.Belief{T, Vlabel, P, V} where {Vlabel<:(AbstractVector), P<:AbstractMatrix{T}, V<:AbstractVector{T}})}","page":"Home","title":"PhyloGaussianBeliefProp.init_messageresidual_allocate","text":"init_messageresidual_allocate(beliefs::Vector{B}, nclusters)\n\nDictionary of 2k residuals of type MessageResidual, whose canonical parameters (Δh,ΔJ) are initialized using MessageResidual, to be of the same size as sepsets in beliefs, where k is length(beliefs) - nclusters. Assumption: the first nclusters beliefs are cluster beliefs, and the next k beliefs are sepset beliefs. This is not checked.\n\nThe sepset for edge (label1,label2) is associated with 2 messages, for the 2 directions in which beliefs can be propagated along the edge. The keys for these messages are (label1,label2) and (label2,label1).\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.inscope_onenode-Tuple{Any, PhyloGaussianBeliefProp.Belief}","page":"Home","title":"PhyloGaussianBeliefProp.inscope_onenode","text":"inscope_onenode(node_label, b:Belief)\n\nAbstractVector: view of the row vector in b's inscope matrix corresponding to node node_label, indicating whether a trait at that node is in scope or not.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.integratebelief!-Tuple{PhyloGaussianBeliefProp.AbstractBelief}","page":"Home","title":"PhyloGaussianBeliefProp.integratebelief!","text":"integratebelief!(belief::AbstractBelief)\nintegratebelief(h,J,g)\n\n(μ,g) from fully integrating the belief, that is: μ = J^-1 h and g + (log2pi J^-1 + h^T J^-1 h)2  The first form updates belief.μ.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.integratebelief!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph, Any}","page":"Home","title":"PhyloGaussianBeliefProp.integratebelief!","text":"integratebelief!(obj::ClusterGraphBelief, beliefindex)\nintegratebelief!(obj::ClusterGraphBelief)\nintegratebelief!(obj::ClusterGraphBelief, clustergraph, nodevector_preordered)\n\n(μ,g) from fully integrating the object belief indexed beliefindex. This belief is modified, with its belief.μ's values updated to those in μ.\n\nThe second method uses the first sepset containing a single node. This is valid if the beliefs are fully calibrated (including a pre-order traversal), but invalid otherwise. The third method uses the default cluster containing the root, see default_rootcluster. This is valid if the same cluster was used as the root of the cluster graph, if this graph is a clique tree, and after a post-order traversal to start the calibration.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.iscalibrated_kl!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}} where T","page":"Home","title":"PhyloGaussianBeliefProp.iscalibrated_kl!","text":"iscalibrated_kl!(res::AbstractResidual, atol=1e-5)\n\nTrue if the KL divergence stored in res.kldiv is within atol of 0; false otherwise. res.iscalibrated_kl is modified accordingly. This KL divergence should have been previously calculated: between a sepset belief, equal to the message that was passed most recently, and its belief just prior to passing that message.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.iscalibrated_residnorm!-Union{Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}}, Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, Any, Real}} where T","page":"Home","title":"PhyloGaussianBeliefProp.iscalibrated_residnorm!","text":"iscalibrated_residnorm!(res::AbstractResidual, atol=1e-5, p::Real=Inf)\n\nTrue if the canonical parameters res.Δh and res.ΔJ of the message residual have p-norm within atol of 0; false otherwise. res.iscalibrated_resid is updated accordingly.\n\nWith p infinite, the max norm is used by default, meaning that res.Δh and res.ΔJ should be close to 0 element-wise.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.iscalibrated_residnorm-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief}","page":"Home","title":"PhyloGaussianBeliefProp.iscalibrated_residnorm","text":"iscalibrated_residnorm(beliefs::ClusterGraphBelief)\niscalibrated_kl(beliefs::ClusterGraphBelief)\n\nTrue if all edges in the cluster graph have calibrated messages in both directions, in that their latest message residuals have norm close to 0 (residnorm) or KL divergence close to 0 between the message received and prior sepset belief. False if not all edges have calibrated messages.\n\nThis condition is sufficient but not necessary for calibration.\n\nCalibration was determined for each individual message residual by iscalibrated_residnorm! and iscalibrated_kl! using some tolerance value.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.isdegenerate-Tuple{PhyloNetworks.Node}","page":"Home","title":"PhyloGaussianBeliefProp.isdegenerate","text":"isdegenerate(node)\n\ntrue if all parent edges of node have length 0, false otherwise. Intended for hybrid nodes, as tree edges of length 0 should be suppressed before trait evolution analysis.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.isfamilypreserving-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, PhyloNetworks.HybridNetwork}} where T<:Integer","page":"Home","title":"PhyloGaussianBeliefProp.isfamilypreserving","text":"isfamilypreserving(clusters, net)\n\nTuple (ispreserving, isfamily_incluster):\n\nispreserving: true (false) if clusters is (is not) family-preserving with respect to net, that is: if each node family (a node and all of its parents) in net is contained in at least 1 cluster in clusters. clusters should be a vector, where each element describes one cluster, given as a vector of preorder indices. Index i corresponds to node number i in net according the node pre-ordering: net.nodes_changed[i].\nisfamily_incluster: vector of BitVectors. isfamily_incluster[i][j] is true (false) if the family of node i is (is not) fully contained in cluster [j]. i is taken as the preorder index of a node in net. ispreserving is true if every element (bit vector) in isfamily_incluster  contains at least 1 true value.\n\nWarning: assumes that net is preordered, see PhyloNetworks.preorder!).\n\nSee also nodefamilies to get node families.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.ishybridsinglepositivechild-Tuple{PhyloNetworks.Node}","page":"Home","title":"PhyloGaussianBeliefProp.ishybridsinglepositivechild","text":"ishybridsinglepositivechild(node)\n\ntrue if node is a hybrid node with a single child edge of positive length. If it isdegenerate) (all its parent edges have length 0) and if its child is a tree node, then it could be removed from scope: see unscope.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.joingraph-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.JoinGraphStructuring}","page":"Home","title":"PhyloGaussianBeliefProp.joingraph","text":"joingraph(net, method::JoinGraphStructuring)\n\nSee JoinGraphStructuring\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.ltripclustergraph-Tuple{PhyloNetworks.HybridNetwork, PhyloGaussianBeliefProp.LTRIP}","page":"Home","title":"PhyloGaussianBeliefProp.ltripclustergraph","text":"ltripclustergraph(net, method::LTRIP)\n\nSee LTRIP\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.marginalizebelief-Tuple{PhyloGaussianBeliefProp.AbstractBelief, Any}","page":"Home","title":"PhyloGaussianBeliefProp.marginalizebelief","text":"marginalizebelief(belief::AbstractBelief, keep_index)\nmarginalizebelief(h,J,g, keep_index, beliefmetadata)\nmarginalizebelief(h,J,g, keep_index, integrate_index, beliefmetadata)\n\nCanonical form (h,J,g) of the input belief, after all variables except those at indices keep_index have been integrated out. If we use I and S subscripts to denote subvectors and submatrices at indices to integrate out (I: integrate_index) and indices to keep (S: save for sepset, keep_index) then the returned belief parameters are:\n\nh_S - J_SI J_I^-1 h_I\n\nJ_S - J_SI J_I^-1 J_IS\n\nand\n\ng + (log2pi J_I^-1 + h_I^T J_I^-1 h_I)2 \n\nThese operations fail if the Cholesky decomposition of J_I fails. In that case, an error of type BPPosDefException is thrown with a message about the beliefmetadata, which can be handled by downstream functions.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.moralize","page":"Home","title":"PhyloGaussianBeliefProp.moralize","text":"moralize!(net::HybridNetwork, prefix=\"I\")\nmoralize(net)\n\nUndirected graph g of type MetaGraph with the same nodes as in net, labelled by their names in net, with extra edges to moralize the graph, that is, to connect any nodes with a common child. Node data, accessed as g[:nodelabel], is their index in the network's preordering. Edge data, accessed as g[:label1, :label2] is a type to indicate if the edge was an original tree edge or hybrid edge, or added to moralize the graph. Another type, not used here, if for fill edges that may need to be added to triangulate g (make it chordal).\n\nThe first version modifies net to name its internal nodes (used as labels in g) and to create or update its node preordering, then calls the second version.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.moralize!","page":"Home","title":"PhyloGaussianBeliefProp.moralize!","text":"moralize!(net::HybridNetwork, prefix=\"I\")\nmoralize(net)\n\nUndirected graph g of type MetaGraph with the same nodes as in net, labelled by their names in net, with extra edges to moralize the graph, that is, to connect any nodes with a common child. Node data, accessed as g[:nodelabel], is their index in the network's preordering. Edge data, accessed as g[:label1, :label2] is a type to indicate if the edge was an original tree edge or hybrid edge, or added to moralize the graph. Another type, not used here, if for fill edges that may need to be added to triangulate g (make it chordal).\n\nThe first version modifies net to name its internal nodes (used as labels in g) and to create or update its node preordering, then calls the second version.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.nodefamilies-Tuple{PhyloNetworks.HybridNetwork}","page":"Home","title":"PhyloGaussianBeliefProp.nodefamilies","text":"nodefamilies(net)\n\nVector v with elements of type Vector{T}. v[i] first lists i, the preorder index of node net.nodes_changed[i], followed by the preorder index of all of this node's parents in net, sorted in decreasing order. Due to pre-ordering, all of the parents' indices are listed after the node (their child) index. A given node and its parents is called a \"node family\".\n\nWarning: net is assumed preordered, see preprocessnet! and PhyloNetworks.preorder!).\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.nodesubtree-Tuple{MetaGraphsNext.MetaGraph, Symbol}","page":"Home","title":"PhyloGaussianBeliefProp.nodesubtree","text":"nodesubtree(clustergraph::MetaGraph, node_symbol)\nnodesubtree(clustergraph::MetaGraph, node_symbol, node_preorderindex)\n\nMetaGraph subgraph of clustergraph induced by the clusters and sepsets containing the node labelled node_symbol (of specified preorder index if known, not checked). If clustergraph satisfies the generalized running-intersection property, then this subgraph should be a tree.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.nodesubtree_clusterlist-Tuple{MetaGraphsNext.MetaGraph, Symbol}","page":"Home","title":"PhyloGaussianBeliefProp.nodesubtree_clusterlist","text":"nodesubtree_clusterlist(clustergraph::MetaGraph, nodesymbol)\n\nSpanning tree of the subgraph of clustergraph induced by the clusters and sepsets that contain the node labelled nodesymbol, see nodesubtree. If clustergraph satisfies the generalized running-intersection property, then this subgraph should be a tree anyway, but this is not assumed (via extracting a spanning tree).\n\nOutput: tuple of 4 vectors describing a depth-first search traversal of the tree, starting from a cluster containing the node of smallest preorder index, as determined by default_rootcluster. Each element in this tuple is a vector: see spanningtree_clusterlist.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.params-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel}","page":"Home","title":"PhyloGaussianBeliefProp.params","text":"params(m::EvolutionaryModel)\n\nTuple of parameters, the same that can be used to construct the evolutionary model.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.params_optimize-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel}","page":"Home","title":"PhyloGaussianBeliefProp.params_optimize","text":"params_optimize(m::EvolutionaryModel)\n\nTuple of transformed parameters for model m, in an unconstrained space that can be used for numerical optimization.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.params_original-Tuple{PhyloGaussianBeliefProp.EvolutionaryModel, AbstractArray}","page":"Home","title":"PhyloGaussianBeliefProp.params_original","text":"params_original(m::EvolutionaryModel, transformedparams::AbstractArray)\n\nTuple of parameters for model m in the original space, corresponding to back-transformed  parameters of transformedparams, and that can be used as input to the model constructor.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.parentinformation-Tuple{PhyloNetworks.Node, PhyloNetworks.HybridNetwork}","page":"Home","title":"PhyloGaussianBeliefProp.parentinformation","text":"parentinformation(node, net)\n\nTuple of (edge length, edge γ, index of parent node in net.nodes_changed) for all parent edges of node. Assumes that net has been preordered before.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.preprocessnet!","page":"Home","title":"PhyloGaussianBeliefProp.preprocessnet!","text":"preprocessnet!(net::HybridNetwork, prefix=\"I\")\n\nCreate or update the pre-ordering of nodes in net using PhyloNetworks.preorder!, then name unnamed internal nodes, with names starting with prefix. Nodes in phylogenetic networks need to have names to build cluster graphs, in which a cluster contains network nodes. Pre-ordering is also used to traverse the network for building cluster graphs.\n\nSee clustergraph!.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.propagate_1traversal_postorder!","page":"Home","title":"PhyloGaussianBeliefProp.propagate_1traversal_postorder!","text":"propagate_1traversal_postorder!(beliefs::ClusterGraphBelief, spanningtree...)\npropagate_1traversal_preorder!(beliefs::ClusterGraphBelief,  spanningtree...)\n\nMessages are propagated along the spanning tree, from the tips to the root by propagate_1traversal_postorder! and from the root to the tips by propagate_1traversal_preorder!.\n\nThe \"spanning tree\" should be a tuple of 4 vectors as output by spanningtree_clusterlist, meant to list edges in preorder. Its nodes (resp. edges) should correspond to clusters (resp. sepsets) in beliefs: labels and indices in the spanning tree information should correspond to indices in beliefs. This condition holds if beliefs are produced on a given cluster graph and if the tree is produced by spanningtree_clusterlist on the same graph.\n\nOptional positional arguments after spanning tree, in this order (default value):\n\nverbose (true): log error messages about degenerate messages that failed to be passed.\nupdate_residualnorm (true): to update each message residual's iscalibrated_resid\nupdate_residualkldiv (false): to update each message residual's field kldiv: KL divergence between the new and old sepset beliefs, normalized to be considered as (conditional) distributions.\n\n\n\n\n\n","category":"function"},{"location":"#PhyloGaussianBeliefProp.propagate_belief!-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractResidual}","page":"Home","title":"PhyloGaussianBeliefProp.propagate_belief!","text":"propagate_belief!(cluster_to, sepset, cluster_from, residual)\n\nUpdate the canonical parameters of the beliefs in cluster_to and in sepset, by marginalizing the belief in cluster_from to the sepset's variable and passing that message. The change in sepset belief (Δh and ΔJ: new - old) is stored in residual.\n\nDegeneracy\n\nPropagating a belief requires the cluster_from belief to have a non-degenerate J_I: submatrix of J for the indices to be integrated out. Problems arise if this submatrix has one or more 0 eigenvalues, or infinite values (see marginalizebelief). If so, a BPPosDefException is returned but not thrown. Downstream functions should try & catch these failures, and decide how to proceed. See regularizebeliefs_bycluster! to reduce the prevalence of degeneracies.\n\nOutput\n\nnothing if the message was calculated with success\na BPPosDefException object if marginalization failed. In this case, the error is not thrown: downstream functions should check for failure (and may choose to throw the output error object).\n\nWarnings\n\nonly the h, J and g parameters are updated, not μ.\nDoes not check that cluster_from and cluster_to are of cluster type, or that sepset is of sepset type, but does check that the labels and scope of sepset are included in each cluster.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.regularizebeliefs_1clustersepset!-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief, Any}","page":"Home","title":"PhyloGaussianBeliefProp.regularizebeliefs_1clustersepset!","text":"regularizebeliefs_1clustersepset!(cluster::AbstractBelief, sepset::AbstractBelief, ϵ)\n\nModify beliefs of 1 cluster and 1 of sepset, assumed to be neighbors in a cluster graph (such that the sepset's scope is a subset of the cluster's scope) by adding ϵ to all diagonal elements of the sepset precision matrice J and to the corresponding diagonal elements of the cluster precision, so as to preserve the full graphical model.\n\nUsed by regularizebeliefs_bycluster! and regularizebeliefs_onschedule!.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.regularizebeliefs_bycluster!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}","page":"Home","title":"PhyloGaussianBeliefProp.regularizebeliefs_bycluster!","text":"regularizebeliefs_bycluster!(beliefs::ClusterGraphBelief, clustergraph)\nregularizebeliefs_bycluster!(beliefs::ClusterGraphBelief, clustergraph, cluster_label)\n\nModify beliefs of cluster graph by adding positive values to some diagonal elements of precision matrices J, while preserving the full graphical model (product of cluster beliefs over product of sepset beliefs, invariant during belief propagation) so that all beliefs are non-degenerate.\n\nThis regularization could be done after initialization with init_beliefs_assignfactors! for example.\n\nThe goal is that at each later step of belief propagation, the sending cluster has a non-degenerate (positive definite) precision matrix for the variables to be integrated, so that the message to be sent is well-defined (i.e. can be computed) and positive semidefinite.\n\nAlgorithm\n\nFor each cluster Ci (or for only for 1 cluster, labeled cluster_label):\n\nFind a regularization parameter adaptively for that cluster: ϵ = maximum absolute value of all entries in Ci's precision matrix J, and of the machine epsilon.   Then loop through its incident edges:\nFor each neighbor cluster Cj and associated sepset Sij, add ϵ > 0 to the diagonal entries of Ci's precision matrix J corresponding to the traits in Sij.\nTo preserve the graphical model's joint distribution for the full set of variables (invariant during BP), the same ϵ is added to each diagonal entry of Sij's precision matrix.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.regularizebeliefs_bynodesubtree!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}","page":"Home","title":"PhyloGaussianBeliefProp.regularizebeliefs_bynodesubtree!","text":"regularizebeliefs_bynodesubtree!(beliefs::ClusterGraphBelief, clustergraph)\n\nModify beliefs of cluster graph by adding positive values to some diagonal elements of precision matrices J, while preserving the full graphical model (product of cluster beliefs over product of sepset beliefs, invariant during belief propagation) so that all beliefs are non-degenerate.\n\nThe goal is the same as regularizebeliefs_bycluster! and regularizebeliefs_onschedule!, but the algorithm is different.\n\nAlgorithm\n\nFor each node (or variable) v:\n\nConsider the subgraph T of clusters & edges that have v. If clustergraph has the generalized running-intersection property, this subgraph is a tree.\nRoot T at a cluster containing a node with the largest postorder index.\nFind a regularization parameter adaptively for that node: ϵ = maximum absolute value of all entries in Ci's precision matrix J, and of the machine epsilon, over clusters Ci in T.\nFor each trait j, find the subtree Tj of clusters and sepsets that have trait j of node v in their scope.\nFor each cluster and sepset in Tj, except at its cluster root: add ϵ on the diagonal of their belief precision matrix J corresponding to trait j of node v.\nCheck that graphical model invariant is preserved, that is: for each trait j, ϵ was added to the same number of clusters as number of sepsets.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.regularizebeliefs_onschedule!-Tuple{PhyloGaussianBeliefProp.ClusterGraphBelief, MetaGraphsNext.MetaGraph}","page":"Home","title":"PhyloGaussianBeliefProp.regularizebeliefs_onschedule!","text":"regularizebeliefs_onschedule!(beliefs::ClusterGraphBelief, clustergraph)\n\nModify beliefs of the cluster graph so that all beliefs are non-degenerate, by (1) adding positive values to some diagonal elements of precision matrices J while preserving the full graphical model, and (2) propagating messages by marginalizing cluster beliefs.\n\nThe goal is the same as regularizebeliefs_bycluster! and regularizebeliefs_bynodesubtree!, but the algorithm is different.\n\nAlgorithm\n\nThe outcomes depends on a \"schedule\", that is, on an order in which clusters are considered. Here, the method simply takes the order given by labels(clustergraph). Mark all messages Ci → Cj as un-sent. For each cluster Ci in order:\n\nFor each neighbor cluster Cj of Ci, if the message Cj → Ci has not been sent, then:\nadd ϵ_i to the diagonal entries of sepset Sij's precision matrix Jij\nadd ϵ_i to the diagonal entries of Ci's precision matrix Ji that correspond to the inscope variables of Sij\nmark Cj → Ci as sent.\nNotes:\nϵ_i is taken as the maximum of all absolute values of entries in Ji, and of the square root of machine epsilon.\nThis is equivalent to \"sending\" a default message, that is not computed from Cj's belief, with diagonal precision matrix ϵ⋅I and other canonical parameters h=0, g=0.\nFor each neighbor cluster Cj of Ci, if Ci → Cj has not been sent then\nsend a message from Ci to Cj by marginalizing Ci's belief (that is, using belief propagation).\nmark the message Ci → Cj as sent.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.residual_kldiv!-Union{Tuple{T}, Tuple{PhyloGaussianBeliefProp.AbstractResidual{T}, PhyloGaussianBeliefProp.AbstractBelief{T}}} where T<:Real","page":"Home","title":"PhyloGaussianBeliefProp.residual_kldiv!","text":"residual_kldiv!(residual::AbstractResidual, sepset::AbstractBelief,\n    canonicalparams::Tuple)\n\nUpdate residual.kldiv with the Kullback-Leibler divergence between a message sent through a sepset (normalized to a probability distribution), and the sepset belief before the belief update (also normalized). sepset should contain the updated belief, and residual the difference in the J and h parameters due to the belief update (after - before), such that the previous belief is: sepset belief - residual. As a side product, sepset.μ is updated.\n\nOutput: true if the KL divergence is close to 0, false otherwise. See iscalibrated_kl! for the tolerance.\n\nIf the current or previous sepset belief is degenerate, in the sense that its precision matrix is not positive definite and the belief cannot be normalized to a proper distribution, then residual and sepset are not updated, and false is returned. No warning and no error is sent, because sepset beliefs are initialized at 0 and this case is expected to be frequent before enough messages are sent.\n\nCalculation:\n\nsepset after belief-update (i.e. message sent): C(x | Jₘ, hₘ, gₘ) ∝ density for     X ~ 𝒩(μ=Jₘ⁻¹hₘ, Σ=Jₘ⁻¹)   sepset before belief-update: C(x | Jₛ, hₛ, gₛ)   residual: ΔJ = Jₘ - Jₛ, Δh = hₘ - hₛ   p: dimension of X (number of variables: number of nodes * number of traits). Below, we use the notation Δg for the change in constants to normalize each message, which is not gₘ-gₛ because the stored beliefs are not normalized.\n\nKL(C(Jₘ, hₘ, _) || C(Jₛ, hₛ, _))\n= Eₘ[log C(x | Jₘ,hₘ,_)/C(x | Jₛ,hₛ,_)] where x ∼ C(Jₘ,hₘ,_)\n= Eₘ[-(1/2) x'ΔJx + Δh'x + Δg)]\n= (  tr(JₛJₘ⁻¹) - p + (μₛ-μₘ)'Jₛ(μₛ-μₘ) + log(det(Jₘ)/det(Jₛ))  ) /2\n\nSee also: average_energy!, which only requires the sepset belief to be positive definite.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.scopeindex-Tuple{Any, PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief}","page":"Home","title":"PhyloGaussianBeliefProp.scopeindex","text":"scopeindex(node_label, sepset::AbstractBelief, cluster::AbstractBelief)\n\nTuple of 2 index vectors (ind_in_sepset, ind_in_cluster) in the sepset and in the cluster in-scope variables (that is, in the cluster's μ,h,J vectors and matrices) of the shared in-scope traits for node node_label, such that sepset.μ[ind_in_sepset] correspond to all the node's traits in the sepset scope and cluster.μ[ind_in_cluster] correspond to the same traits in the cluster scope, which may be a subset of all the node's traits in scope for that cluster. If not, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.scopeindex-Tuple{Integer, PhyloGaussianBeliefProp.AbstractBelief}","page":"Home","title":"PhyloGaussianBeliefProp.scopeindex","text":"scopeindex(j::Integer, belief::AbstractBelief)\n\nIndices in the belief's μ,h,J vectors and matrices of the traits in scope for node indexed j in nodelabels(belief).\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.scopeindex-Tuple{PhyloGaussianBeliefProp.AbstractBelief, PhyloGaussianBeliefProp.AbstractBelief}","page":"Home","title":"PhyloGaussianBeliefProp.scopeindex","text":"scopeindex(sepset::AbstractBelief, cluster::AbstractBelief)\n\nIndices ind, in the cluster in-scope variables (that is, in the cluster's μ,h,J vectors and matrices) of the sepset in-scope variables, such that cluster.μ[ind] correspond to the same variables as sepset.μ, for example. These sepset in-scope variables can be a subset of traits for each node in the sepset, as indicated by inscope(sepset).\n\nWarning: the labels in the sepset are assumed to be ordered as in the cluster.\n\nAn error is returned if sepset contains labels not in the cluster, or if a variable in the sepset's scope is not in scope in the cluster.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.scopeindex-Tuple{Union{Tuple, AbstractVector}, PhyloGaussianBeliefProp.AbstractBelief}","page":"Home","title":"PhyloGaussianBeliefProp.scopeindex","text":"scopeindex(node_labels::Union{Tuple,AbstractVector}, belief::AbstractBelief)\n\nIndices in the belief's μ,h,J vectors and matrices of the variables for nodes labeled node_labels. The belief's inscope matrix of booleans says which node (column) and trait (row) is in the belief's scope. These variables are vectorized by stacking up columns, that is, listing all in-scope traits of the first node, then all in-scope traits of the second node etc.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.shrinkdegenerate_treeedges-Tuple{PhyloNetworks.HybridNetwork}","page":"Home","title":"PhyloGaussianBeliefProp.shrinkdegenerate_treeedges","text":"shrinkdegenerate_treeedges(net::HybridNetwork)\n\nNetwork obtained from net with any non-external tree edge of length 0 suppressed. Returns an error if any edge length is missing or negative, or if any γ is missing or non positive. It is assumed that γs sum to 1 across partner hybrid edges.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.spanningtree_clusterlist-Tuple{MetaGraphsNext.MetaGraph, Vector{PhyloNetworks.Node}}","page":"Home","title":"PhyloGaussianBeliefProp.spanningtree_clusterlist","text":"spanningtree_clusterlist(clustergraph, root_index)\nspanningtree_clusterlist(clustergraph, nodevector_preordered)\n\nBuild the depth-first search spanning tree of the cluster graph, starting from the cluster indexed root_index in the underlying simple graph; find the associated topological ordering of the clusters (preorder); then return a tuple of these four vectors:\n\nparent_labels: labels of the parents' child clusters. The first one is the root.\nchild_labels: labels of clusters in pre-order, except for the cluster  choosen to be the root.\nparent_indices: indices of the parent clusters\nchild_indices: indices of the child clusters, listed in preorder as before.\n\nIn the second version in which root_index is not provided, the root of the spanning tree is chosen to be a cluster that contains the network's root. If multiple clusters contain the network's root, then one is chosen containing the smallest number of taxa: see default_rootcluster.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.spanningtrees_clusterlist-Union{Tuple{T}, Tuple{MetaGraphsNext.MetaGraph{T, Graph} where Graph<:Graphs.AbstractGraph{T}, Vector{PhyloNetworks.Node}}} where T","page":"Home","title":"PhyloGaussianBeliefProp.spanningtrees_clusterlist","text":"spanningtrees_clusterlist(clustergraph, nodevector_preordered)\n\nVector of spanning trees for clustergraph, that together cover all edges. Each spanning tree is specified as a tuple of 4 vectors describing a depth-first search traversal of the tree, starting from a cluster that contains the network's root, as in spanningtree_clusterlist.\n\nThe spanning trees are iteratively obtained using Kruskal's minimum-weight spanning tree algorithm, with edge weights defined as the number of previous trees covering the edge.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.triangulate_minfill!-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T","page":"Home","title":"PhyloGaussianBeliefProp.triangulate_minfill!","text":"triangulate_minfill!(graph)\n\nOrdering for node elimination, chosen to greedily minimize the number of fill edges necessary to eliminate the node (to connect all its neighbors with each other). Ties are broken by favoring the post-ordering of nodes. graph is modified with these extra fill edges, making it chordal.\n\n\n\n\n\n","category":"method"},{"location":"#PhyloGaussianBeliefProp.unscope-Tuple{PhyloNetworks.Node}","page":"Home","title":"PhyloGaussianBeliefProp.unscope","text":"unscope(node)\n\ntrue if node is a hybrid node with a single child edge of positive length, and if its child node is a tree node. If it isdegenerate) (all its parent edges have length 0) then it could be removed from scope: see addtreenode_belowdegeneratehybrid!.\n\n\n\n\n\n","category":"method"},{"location":"man/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"For information on how to install Julia and PhyloNetworks, see here. PhyloGaussianBeliefProp depends on PhyloNetworks.","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"To install PhyloGaussianBeliefProp in the Julia REPL, do:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"julia> using Pkg\n\njulia> Pkg.add(\"PhyloGaussianBeliefProp\")","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"Or enter ] in the Julia REPL to access the package mode, and do:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"pkg> add PhyloGaussianBeliefProp","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"In this manual, we will also use PhyloNetworks and other packages, to be installed similarly, here in package mode:","category":"page"},{"location":"man/installation/","page":"Installation","title":"Installation","text":"pkg> add PhyloNetworks\n\npkg> add DataFrames","category":"page"}]
}
